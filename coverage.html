
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/JihadRinaldi/go-shop/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/JihadRinaldi/go-shop/cmd/notifier/main.go (0.0%)</option>
				
				<option value="file2">github.com/JihadRinaldi/go-shop/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/JihadRinaldi/go-shop/internal/database/database.go (0.0%)</option>
				
				<option value="file4">github.com/JihadRinaldi/go-shop/internal/events/watermill.go (0.0%)</option>
				
				<option value="file5">github.com/JihadRinaldi/go-shop/internal/handler/auth_handler.go (0.0%)</option>
				
				<option value="file6">github.com/JihadRinaldi/go-shop/internal/handler/cart_handler.go (0.0%)</option>
				
				<option value="file7">github.com/JihadRinaldi/go-shop/internal/handler/order_handler.go (0.0%)</option>
				
				<option value="file8">github.com/JihadRinaldi/go-shop/internal/handler/product_handler.go (0.0%)</option>
				
				<option value="file9">github.com/JihadRinaldi/go-shop/internal/handler/user_handler.go (0.0%)</option>
				
				<option value="file10">github.com/JihadRinaldi/go-shop/internal/logger/logger.go (0.0%)</option>
				
				<option value="file11">github.com/JihadRinaldi/go-shop/internal/mocks/mock_CartRepositoryInterface.go (0.0%)</option>
				
				<option value="file12">github.com/JihadRinaldi/go-shop/internal/mocks/mock_OrderRepositoryInterface.go (0.0%)</option>
				
				<option value="file13">github.com/JihadRinaldi/go-shop/internal/mocks/mock_ProductRepositoryInterface.go (0.0%)</option>
				
				<option value="file14">github.com/JihadRinaldi/go-shop/internal/mocks/mock_Publisher.go (0.0%)</option>
				
				<option value="file15">github.com/JihadRinaldi/go-shop/internal/mocks/mock_UploadProvider.go (0.0%)</option>
				
				<option value="file16">github.com/JihadRinaldi/go-shop/internal/mocks/mock_UploadRepositoryInterface.go (0.0%)</option>
				
				<option value="file17">github.com/JihadRinaldi/go-shop/internal/mocks/mock_UserRepositoryInterface.go (0.0%)</option>
				
				<option value="file18">github.com/JihadRinaldi/go-shop/internal/notifications/email.go (0.0%)</option>
				
				<option value="file19">github.com/JihadRinaldi/go-shop/internal/providers/aws.go (0.0%)</option>
				
				<option value="file20">github.com/JihadRinaldi/go-shop/internal/providers/local_provider.go (0.0%)</option>
				
				<option value="file21">github.com/JihadRinaldi/go-shop/internal/providers/s3.go (0.0%)</option>
				
				<option value="file22">github.com/JihadRinaldi/go-shop/internal/repositories/cart_repository.go (0.0%)</option>
				
				<option value="file23">github.com/JihadRinaldi/go-shop/internal/repositories/order_repository.go (0.0%)</option>
				
				<option value="file24">github.com/JihadRinaldi/go-shop/internal/repositories/product_repository.go (0.0%)</option>
				
				<option value="file25">github.com/JihadRinaldi/go-shop/internal/repositories/upload_repository.go (0.0%)</option>
				
				<option value="file26">github.com/JihadRinaldi/go-shop/internal/repositories/user_repository.go (0.0%)</option>
				
				<option value="file27">github.com/JihadRinaldi/go-shop/internal/server/middleware.go (0.0%)</option>
				
				<option value="file28">github.com/JihadRinaldi/go-shop/internal/server/server.go (0.0%)</option>
				
				<option value="file29">github.com/JihadRinaldi/go-shop/internal/services/auth_service.go (53.5%)</option>
				
				<option value="file30">github.com/JihadRinaldi/go-shop/internal/services/cart_service.go (11.1%)</option>
				
				<option value="file31">github.com/JihadRinaldi/go-shop/internal/services/order_service.go (21.0%)</option>
				
				<option value="file32">github.com/JihadRinaldi/go-shop/internal/services/product_service.go (41.2%)</option>
				
				<option value="file33">github.com/JihadRinaldi/go-shop/internal/services/upload_service.go (95.0%)</option>
				
				<option value="file34">github.com/JihadRinaldi/go-shop/internal/services/user_service.go (92.9%)</option>
				
				<option value="file35">github.com/JihadRinaldi/go-shop/internal/utils/jwt.go (0.0%)</option>
				
				<option value="file36">github.com/JihadRinaldi/go-shop/internal/utils/password.go (0.0%)</option>
				
				<option value="file37">github.com/JihadRinaldi/go-shop/internal/utils/response.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/database"
        "github.com/JihadRinaldi/go-shop/internal/logger"
        "github.com/JihadRinaldi/go-shop/internal/server"
        "github.com/gin-gonic/gin"
)

func main() <span class="cov0" title="0">{

        log := logger.New()
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to load configuration")
        }</span>

        <span class="cov0" title="0">db, err := database.New(&amp;cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to connect to database")
        }</span>

        <span class="cov0" title="0">mainDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to get database instance")
        }</span>

        <span class="cov0" title="0">defer mainDB.Close()
        gin.SetMode(cfg.Server.GinMode)

        srv := server.New(cfg, db, &amp;log)

        router := srv.SetupRoutes()

        httpServer := &amp;http.Server{
                Addr:         fmt.Sprintf(":%s", cfg.Server.Port),
                Handler:      router,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
        }

        go func() </span><span class="cov0" title="0">{
                log.Info().Str("port", cfg.Server.Port).Msg("starting HTTP server")
                if err := httpServer.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("HTTP server error")
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Info().Msg("shutting down server...")
        ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
        defer cancel()

        if err := httpServer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("server forced to shutdown")
                return
        }</span>

        <span class="cov0" title="0">log.Info().Msg("server exiting")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "encoding/json"
        "log"
        "os"
        "os/signal"
        "syscall"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/models"
        "github.com/JihadRinaldi/go-shop/internal/notifications"
        "github.com/JihadRinaldi/go-shop/internal/providers"
        "github.com/ThreeDotsLabs/watermill"
        "github.com/ThreeDotsLabs/watermill-aws/sqs"
        "github.com/ThreeDotsLabs/watermill/message"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">emailConfig := &amp;notifications.SMTPConfig{
                Host:     cfg.SMTP.Host,
                Port:     cfg.SMTP.Port,
                Username: cfg.SMTP.Username,
                Password: cfg.SMTP.Password,
                From:     cfg.SMTP.From,
        }

        emailNotifier := notifications.NewEmailNotifier(emailConfig)

        awsConfig, err := providers.CreateAWSConfig(ctx, cfg.AWS.S3Endpoint, cfg.AWS.Region)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create AWS config: %v", err)
        }</span>

        <span class="cov0" title="0">logger := watermill.NewStdLogger(false, false)
        subscriber, err := sqs.NewSubscriber(sqs.SubscriberConfig{AWSConfig: awsConfig}, logger)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to create SQS subscriber: %v", err)
        }</span>

        <span class="cov0" title="0">messages, err := subscriber.Subscribe(ctx, cfg.AWS.EventQueueName)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to subscribe to SQS queue: %v", err)
        }</span>

        // Handle graceful shutdown
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        log.Println("Notification service started. Waiting for messages...")

        for </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-messages:<span class="cov0" title="0">
                        if err := processMessage(msg, emailNotifier); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error processing message: %v", err)
                                msg.Nack()
                        }</span> else<span class="cov0" title="0"> {
                                msg.Ack()
                        }</span>
                case &lt;-sigChan:<span class="cov0" title="0">
                        log.Println("Shutting down notification service...")
                        subscriber.Close()
                        return</span>
                }
        }
}

func processMessage(msg *message.Message, emailNotifier *notifications.EmailNotifier) error <span class="cov0" title="0">{
        eventType := msg.Metadata.Get("event_type")
        switch eventType </span>{
        case notifications.UserLoggedIn:<span class="cov0" title="0">
                return handleUserLoggedIn(msg, emailNotifier)</span>
        default:<span class="cov0" title="0">
                log.Printf("Unknown event type: %s", eventType)
                return nil</span>
        }
}

func handleUserLoggedIn(msg *message.Message, emailNotifier *notifications.EmailNotifier) error <span class="cov0" title="0">{
        var user models.User
        if err := json.Unmarshal(msg.Payload, &amp;user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">userName := user.FirstName + " " + user.LastName
        if userName == " " </span><span class="cov0" title="0">{
                userName = "User"
        }</span>

        <span class="cov0" title="0">log.Printf("Sending login notification to %s", user.Email)

        return emailNotifier.SendLoginNotification(user.Email, userName)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"
        "strconv"
        "time"

        "github.com/joho/godotenv"
)

type Config struct {
        Server   ServerConfig
        Database DatabaseConfig
        JWT      JWTConfig
        AWS      AWSConfig
        Upload   UploadConfig
        SMTP     SMTPConfig
}

type ServerConfig struct {
        Port    string
        GinMode string
}

type DatabaseConfig struct {
        Host     string
        Port     string
        User     string
        Password string
        Name     string
        SSLMode  string
}

type JWTConfig struct {
        SecretKey           string
        ExpireIn            time.Duration
        RefreshTokenExpires time.Duration
}

type AWSConfig struct {
        Region          string
        AccessKeyID     string
        SecretAccessKey string
        S3Bucket        string
        S3Endpoint      string
        EventQueueName  string
}

type UploadConfig struct {
        Path           string
        MaxFileSize    int64
        UploadProvider string
}

type SMTPConfig struct {
        Host     string
        Port     int
        Username string
        Password string
        From     string
}

func Load() (*Config, error) <span class="cov0" title="0">{
        _ = godotenv.Load()

        jwtExpiresIn, _ := time.ParseDuration(getEnv("JWT_EXPIRES_IN", "24h"))
        refreshTokenExpires, _ := time.ParseDuration(getEnv("REFRESH_TOKEN_EXPIRES_IN", "720h"))
        maxUploadSize, _ := strconv.ParseInt(getEnv("MAX_UPLOAD_SIZE", "10485760"), 10, 64)
        smtpPort, _ := strconv.Atoi(getEnv("SMTP_PORT", "1025"))

        return &amp;Config{
                Server: ServerConfig{
                        Port:    getEnv("PORT", "8080"),
                        GinMode: getEnv("GIN_MODE", "debug"),
                },
                Database: DatabaseConfig{
                        Host:     getEnv("DB_HOST", "localhost"),
                        Port:     getEnv("DB_PORT", "5432"),
                        User:     getEnv("DB_USER", "postgres"),
                        Password: getEnv("DB_PASSWORD", "password"),
                        Name:     getEnv("DB_NAME", "go_shop"),
                        SSLMode:  getEnv("DB_SSL_MODE", "disable"),
                },
                JWT: JWTConfig{
                        SecretKey:           getEnv("JWT_SECRET", "your-super-secret-jwt-key"),
                        ExpireIn:            jwtExpiresIn,
                        RefreshTokenExpires: refreshTokenExpires,
                },
                AWS: AWSConfig{
                        Region:          getEnv("AWS_REGION", "us-east-1"),
                        AccessKeyID:     getEnv("AWS_ACCESS_KEY_ID", "test"),
                        SecretAccessKey: getEnv("AWS_SECRET_ACCESS_KEY", "test"),
                        S3Bucket:        getEnv("AWS_S3_BUCKET", "uploads"),
                        S3Endpoint:      getEnv("AWS_S3_ENDPOINT", "http://localhost:4566"),
                        EventQueueName:  getEnv("AWS_EVENT_QUEUE_NAME", "event-queue"),
                },
                Upload: UploadConfig{
                        Path:           getEnv("UPLOAD_PATH", "./uploads"),
                        MaxFileSize:    maxUploadSize,
                        UploadProvider: getEnv("UPLOAD_PROVIDER", "local"),
                },
                SMTP: SMTPConfig{
                        Host:     getEnv("SMTP_HOST", "localhost"),
                        Port:     smtpPort,
                        Username: getEnv("SMTP_USERNAME", ""),
                        Password: getEnv("SMTP_PASSWORD", ""),
                        From:     getEnv("SMTP_FROM", "noreply@shop.com"),
                },
        }, nil

}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>

        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "fmt"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func New(cfg *config.DatabaseConfig) (*gorm.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s TimeZone=UTC",
                cfg.Host,
                cfg.Port,
                cfg.User,
                cfg.Password,
                cfg.Name,
                cfg.SSLMode,
        )

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package events

import (
        "context"
        "encoding/json"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/providers"
        "github.com/ThreeDotsLabs/watermill"
        "github.com/ThreeDotsLabs/watermill-aws/sqs"
        "github.com/ThreeDotsLabs/watermill/message"
)

type EventPublisher struct {
        publisher message.Publisher
        queueName string
}

func (p *EventPublisher) Publish(eventType string, payload interface{}, metadata map[string]string) error <span class="cov0" title="0">{

        data, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">msg := message.NewMessage(watermill.NewUUID(), data)

        msg.Metadata.Set("event_type", eventType)
        for k, v := range metadata </span><span class="cov0" title="0">{
                msg.Metadata.Set(k, v)
        }</span>

        <span class="cov0" title="0">return p.publisher.Publish(p.queueName, msg)</span>
}

func (p *EventPublisher) Close() error <span class="cov0" title="0">{
        return p.publisher.Close()
}</span>

func NewEventPublisher(ctx context.Context, cfg config.AWSConfig) (*EventPublisher, error) <span class="cov0" title="0">{
        logger := watermill.NewStdLogger(false, false)

        awsConfig, err := providers.CreateAWSConfig(ctx, cfg.S3Endpoint, cfg.Region)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">publisherConfig := sqs.PublisherConfig{
                AWSConfig: awsConfig,
                Marshaler: nil,
        }

        publisher, err := sqs.NewPublisher(publisherConfig, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;EventPublisher{
                publisher: publisher,
                queueName: cfg.EventQueueName,
        }, nil</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/services"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "github.com/gin-gonic/gin"
)

type AuthHandler struct {
        authService *services.AuthService
}

func NewAuthHandler(authService *services.AuthService) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

func (h *AuthHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req dto.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>
        <span class="cov0" title="0">response, err := h.authService.Register(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Registration failed", err)
                return
        }</span>

        <span class="cov0" title="0">utils.CreatedResponse(c, "User registered successfully", response)</span>
}

func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req dto.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>
        <span class="cov0" title="0">response, err := h.authService.Login(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.UnauthorizedResponse(c, "Login failed")
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Login successful", response)</span>
}

func (h *AuthHandler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req dto.RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>
        <span class="cov0" title="0">response, err := h.authService.RefreshToken(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.UnauthorizedResponse(c, "Token refresh failed")
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Token refreshed successfully", response)</span>
}

func (h *AuthHandler) Logout(c *gin.Context) <span class="cov0" title="0">{
        var req dto.RefreshTokenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>
        <span class="cov0" title="0">err := h.authService.Logout(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Logout failed", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Logout successful", nil)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "strconv"

        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/services"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "github.com/gin-gonic/gin"
)

type CartHandler struct {
        cartService *services.CartService
}

func NewCartHandler(cartService *services.CartService) *CartHandler <span class="cov0" title="0">{
        return &amp;CartHandler{
                cartService: cartService,
        }
}</span>

func (h *CartHandler) GetCart(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")

        cart, err := h.cartService.GetCart(userID)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to fetch cart", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Cart fetched", cart)</span>
}

func (h *CartHandler) AddToCart(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")

        var req dto.AddToCartRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>

        <span class="cov0" title="0">cart, err := h.cartService.AddToCart(userID, req)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, err.Error(), err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Item added to cart", cart)</span>
}

func (h *CartHandler) UpdateCartItem(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")

        itemID, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid item ID", err)
                return
        }</span>

        <span class="cov0" title="0">var req dto.UpdateCartItemRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>

        <span class="cov0" title="0">cart, err := h.cartService.UpdateCartItem(userID, uint(itemID), req)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, err.Error(), err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Cart item updated", cart)</span>
}

func (h *CartHandler) RemoveCartItem(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")

        itemID, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid item ID", err)
                return
        }</span>

        <span class="cov0" title="0">if err := h.cartService.RemoveCartItem(userID, uint(itemID)); err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to remove cart item", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Cart item removed", nil)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "strconv"

        "github.com/JihadRinaldi/go-shop/internal/services"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "github.com/gin-gonic/gin"
)

type OrderHandler struct {
        orderService *services.OrderService
}

func NewOrderHandler(orderService *services.OrderService) *OrderHandler <span class="cov0" title="0">{
        return &amp;OrderHandler{
                orderService: orderService,
        }
}</span>

func (h *OrderHandler) CreateOrder(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")
        orderResponse, err := h.orderService.CreateOrder(userID)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Failed to create order", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Order created successfully", orderResponse)</span>
}

func (h *OrderHandler) GetOrder(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")
        orderID, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid order ID", err)
                return
        }</span>

        <span class="cov0" title="0">orderResponse, err := h.orderService.GetOrder(userID, uint(orderID))
        if err != nil </span><span class="cov0" title="0">{
                utils.NotFoundResponse(c, "Order not found")
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Order fetched successfully", orderResponse)</span>
}

func (h *OrderHandler) GetOrders(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

        orders, meta, err := h.orderService.GetOrders(userID, page, limit)

        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Failed to fetch orders", err)
                return
        }</span>

        <span class="cov0" title="0">utils.PaginatedSuccessResponse(c, "Orders fetched successfully", orders, *meta)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "strconv"

        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/services"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "github.com/gin-gonic/gin"
)

type ProductHandler struct {
        productService *services.ProductService
        uploadService  *services.UploadService
}

func NewProductHandler(productService *services.ProductService, uploadService *services.UploadService) *ProductHandler <span class="cov0" title="0">{
        return &amp;ProductHandler{
                productService: productService,
                uploadService:  uploadService,
        }
}</span>

func (h *ProductHandler) CreateCategory(c *gin.Context) <span class="cov0" title="0">{
        var req dto.CreateCategoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>

        <span class="cov0" title="0">category, err := h.productService.CreateCategory(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to create category", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Category created", category)</span>
}

func (h *ProductHandler) GetCategories(c *gin.Context) <span class="cov0" title="0">{
        categories, err := h.productService.GetCategories()
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to fetch categories", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Categories fetched", categories)</span>
}

func (h *ProductHandler) UpdateCategory(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid category ID", err)
                return
        }</span>

        <span class="cov0" title="0">var req dto.UpdateCategoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>

        <span class="cov0" title="0">category, err := h.productService.UpdateCategory(uint(id), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to update category", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Category updated", category)</span>
}

func (h *ProductHandler) DeleteCategory(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid category ID", err)
                return
        }</span>

        <span class="cov0" title="0">if err := h.productService.DeleteCategory(uint(id)); err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to delete category", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Category deleted", nil)</span>
}

func (h *ProductHandler) CreateProduct(c *gin.Context) <span class="cov0" title="0">{
        var req dto.CreateProductRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>

        <span class="cov0" title="0">product, err := h.productService.CreateProduct(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to create product", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Product created", product)</span>
}

func (h *ProductHandler) GetProducts(c *gin.Context) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

        products, meta, err := h.productService.GetProducts(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to fetch products", err)
                return
        }</span>

        <span class="cov0" title="0">utils.PaginatedSuccessResponse(c, "Products fetched", products, *meta)</span>
}

func (h *ProductHandler) GetProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid product ID", err)
                return
        }</span>

        <span class="cov0" title="0">product, err := h.productService.GetProduct(uint(id))
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to fetch product", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Product fetched", product)</span>
}

func (h *ProductHandler) UpdateProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid product ID", err)
                return
        }</span>

        <span class="cov0" title="0">var req dto.UpdateProductRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>

        <span class="cov0" title="0">product, err := h.productService.UpdateProduct(uint(id), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to update product", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Product updated", product)</span>
}

func (h *ProductHandler) DeleteProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid product ID", err)
                return
        }</span>

        <span class="cov0" title="0">if err := h.productService.DeleteProduct(uint(id)); err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to delete product", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Product deleted", nil)</span>
}

func (s *ProductHandler) UploadProductImage(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseUint(c.Param("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid product ID", err)
                return
        }</span>

        <span class="cov0" title="0">file, err := c.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "No file uploaded", err)
                return
        }</span>

        <span class="cov0" title="0">url, err := s.uploadService.UploadProductImage(uint(id), file)
        if err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to upload image", err)
                return
        }</span>

        <span class="cov0" title="0">if err := s.productService.AddProductImage(uint(id), url, file.Filename); err != nil </span><span class="cov0" title="0">{
                utils.InternalServerErrorResponse(c, "Failed to save image record", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Image uploaded successfully", map[string]string{"url": url})</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/services"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "github.com/gin-gonic/gin"
)

type UserHandler struct {
        userService *services.UserService
}

func NewUserHandler(userService *services.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
        }
}</span>

func (h *UserHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")
        profile, err := h.userService.GetProfile(userID)
        if err != nil </span><span class="cov0" title="0">{
                utils.NotFoundResponse(c, "User not found")
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Profile fetched", profile)</span>
}

func (h *UserHandler) UpdateProfile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetUint("user_id")
        var req dto.UpdateProfileRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Invalid request data", err)
                return
        }</span>

        <span class="cov0" title="0">profile, err := h.userService.UpdateProfile(userID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                utils.BadRequestResponse(c, "Failed to update profile", err)
                return
        }</span>

        <span class="cov0" title="0">utils.SuccessResponse(c, "Profile updated", profile)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package logger

import (
        "os"
        "time"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

func New() zerolog.Logger <span class="cov0" title="0">{
        zerolog.TimeFieldFormat = time.RFC3339

        if os.Getenv("GIN_MODE") != "release" </span><span class="cov0" title="0">{
                log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339})
        }</span>

        <span class="cov0" title="0">return log.Logger</span>

}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
        models "github.com/JihadRinaldi/go-shop/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// MockCartRepositoryInterface is an autogenerated mock type for the CartRepositoryInterface type
type MockCartRepositoryInterface struct {
        mock.Mock
}

type MockCartRepositoryInterface_Expecter struct {
        mock *mock.Mock
}

func (_m *MockCartRepositoryInterface) EXPECT() *MockCartRepositoryInterface_Expecter <span class="cov0" title="0">{
        return &amp;MockCartRepositoryInterface_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: cart
func (_m *MockCartRepositoryInterface) Create(cart *models.Cart) error <span class="cov0" title="0">{
        ret := _m.Called(cart)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Cart) error); ok </span><span class="cov0" title="0">{
                r0 = rf(cart)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockCartRepositoryInterface_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockCartRepositoryInterface_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - cart *models.Cart
func (_e *MockCartRepositoryInterface_Expecter) Create(cart interface{}) *MockCartRepositoryInterface_Create_Call <span class="cov0" title="0">{
        return &amp;MockCartRepositoryInterface_Create_Call{Call: _e.mock.On("Create", cart)}
}</span>

func (_c *MockCartRepositoryInterface_Create_Call) Run(run func(cart *models.Cart)) *MockCartRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Cart))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCartRepositoryInterface_Create_Call) Return(_a0 error) *MockCartRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockCartRepositoryInterface_Create_Call) RunAndReturn(run func(*models.Cart) error) *MockCartRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function with given fields: id
func (_m *MockCartRepositoryInterface) Delete(id uint) error <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockCartRepositoryInterface_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockCartRepositoryInterface_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - id uint
func (_e *MockCartRepositoryInterface_Expecter) Delete(id interface{}) *MockCartRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        return &amp;MockCartRepositoryInterface_Delete_Call{Call: _e.mock.On("Delete", id)}
}</span>

func (_c *MockCartRepositoryInterface_Delete_Call) Run(run func(id uint)) *MockCartRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCartRepositoryInterface_Delete_Call) Return(_a0 error) *MockCartRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockCartRepositoryInterface_Delete_Call) RunAndReturn(run func(uint) error) *MockCartRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByUserID provides a mock function with given fields: userID
func (_m *MockCartRepositoryInterface) GetByUserID(userID uint) (*models.Cart, error) <span class="cov0" title="0">{
        ret := _m.Called(userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByUserID")</span>
        }

        <span class="cov0" title="0">var r0 *models.Cart
        var r1 error
        if rf, ok := ret.Get(0).(func(uint) (*models.Cart, error)); ok </span><span class="cov0" title="0">{
                return rf(userID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uint) *models.Cart); ok </span><span class="cov0" title="0">{
                r0 = rf(userID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Cart)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uint) error); ok </span><span class="cov0" title="0">{
                r1 = rf(userID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockCartRepositoryInterface_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockCartRepositoryInterface_GetByUserID_Call struct {
        *mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - userID uint
func (_e *MockCartRepositoryInterface_Expecter) GetByUserID(userID interface{}) *MockCartRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        return &amp;MockCartRepositoryInterface_GetByUserID_Call{Call: _e.mock.On("GetByUserID", userID)}
}</span>

func (_c *MockCartRepositoryInterface_GetByUserID_Call) Run(run func(userID uint)) *MockCartRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCartRepositoryInterface_GetByUserID_Call) Return(_a0 *models.Cart, _a1 error) *MockCartRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockCartRepositoryInterface_GetByUserID_Call) RunAndReturn(run func(uint) (*models.Cart, error)) *MockCartRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: cart
func (_m *MockCartRepositoryInterface) Update(cart *models.Cart) error <span class="cov0" title="0">{
        ret := _m.Called(cart)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Cart) error); ok </span><span class="cov0" title="0">{
                r0 = rf(cart)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockCartRepositoryInterface_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockCartRepositoryInterface_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - cart *models.Cart
func (_e *MockCartRepositoryInterface_Expecter) Update(cart interface{}) *MockCartRepositoryInterface_Update_Call <span class="cov0" title="0">{
        return &amp;MockCartRepositoryInterface_Update_Call{Call: _e.mock.On("Update", cart)}
}</span>

func (_c *MockCartRepositoryInterface_Update_Call) Run(run func(cart *models.Cart)) *MockCartRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Cart))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockCartRepositoryInterface_Update_Call) Return(_a0 error) *MockCartRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockCartRepositoryInterface_Update_Call) RunAndReturn(run func(*models.Cart) error) *MockCartRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockCartRepositoryInterface creates a new instance of MockCartRepositoryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCartRepositoryInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockCartRepositoryInterface <span class="cov0" title="0">{
        mock := &amp;MockCartRepositoryInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
        models "github.com/JihadRinaldi/go-shop/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// MockOrderRepositoryInterface is an autogenerated mock type for the OrderRepositoryInterface type
type MockOrderRepositoryInterface struct {
        mock.Mock
}

type MockOrderRepositoryInterface_Expecter struct {
        mock *mock.Mock
}

func (_m *MockOrderRepositoryInterface) EXPECT() *MockOrderRepositoryInterface_Expecter <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: order
func (_m *MockOrderRepositoryInterface) Create(order *models.Order) error <span class="cov0" title="0">{
        ret := _m.Called(order)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Order) error); ok </span><span class="cov0" title="0">{
                r0 = rf(order)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockOrderRepositoryInterface_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockOrderRepositoryInterface_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - order *models.Order
func (_e *MockOrderRepositoryInterface_Expecter) Create(order interface{}) *MockOrderRepositoryInterface_Create_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_Create_Call{Call: _e.mock.On("Create", order)}
}</span>

func (_c *MockOrderRepositoryInterface_Create_Call) Run(run func(order *models.Order)) *MockOrderRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Order))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepositoryInterface_Create_Call) Return(_a0 error) *MockOrderRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockOrderRepositoryInterface_Create_Call) RunAndReturn(run func(*models.Order) error) *MockOrderRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function with given fields: id
func (_m *MockOrderRepositoryInterface) Delete(id uint) error <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockOrderRepositoryInterface_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockOrderRepositoryInterface_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - id uint
func (_e *MockOrderRepositoryInterface_Expecter) Delete(id interface{}) *MockOrderRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_Delete_Call{Call: _e.mock.On("Delete", id)}
}</span>

func (_c *MockOrderRepositoryInterface_Delete_Call) Run(run func(id uint)) *MockOrderRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepositoryInterface_Delete_Call) Return(_a0 error) *MockOrderRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockOrderRepositoryInterface_Delete_Call) RunAndReturn(run func(uint) error) *MockOrderRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetAll provides a mock function with given fields: limit, offset
func (_m *MockOrderRepositoryInterface) GetAll(limit int, offset int) ([]models.Order, error) <span class="cov0" title="0">{
        ret := _m.Called(limit, offset)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAll")</span>
        }

        <span class="cov0" title="0">var r0 []models.Order
        var r1 error
        if rf, ok := ret.Get(0).(func(int, int) ([]models.Order, error)); ok </span><span class="cov0" title="0">{
                return rf(limit, offset)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(int, int) []models.Order); ok </span><span class="cov0" title="0">{
                r0 = rf(limit, offset)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]models.Order)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(int, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockOrderRepositoryInterface_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockOrderRepositoryInterface_GetAll_Call struct {
        *mock.Call
}

// GetAll is a helper method to define mock.On call
//   - limit int
//   - offset int
func (_e *MockOrderRepositoryInterface_Expecter) GetAll(limit interface{}, offset interface{}) *MockOrderRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_GetAll_Call{Call: _e.mock.On("GetAll", limit, offset)}
}</span>

func (_c *MockOrderRepositoryInterface_GetAll_Call) Run(run func(limit int, offset int)) *MockOrderRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(int), args[1].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepositoryInterface_GetAll_Call) Return(_a0 []models.Order, _a1 error) *MockOrderRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockOrderRepositoryInterface_GetAll_Call) RunAndReturn(run func(int, int) ([]models.Order, error)) *MockOrderRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function with given fields: id
func (_m *MockOrderRepositoryInterface) GetByID(id uint) (*models.Order, error) <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.Order
        var r1 error
        if rf, ok := ret.Get(0).(func(uint) (*models.Order, error)); ok </span><span class="cov0" title="0">{
                return rf(id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uint) *models.Order); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Order)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uint) error); ok </span><span class="cov0" title="0">{
                r1 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockOrderRepositoryInterface_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockOrderRepositoryInterface_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - id uint
func (_e *MockOrderRepositoryInterface_Expecter) GetByID(id interface{}) *MockOrderRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_GetByID_Call{Call: _e.mock.On("GetByID", id)}
}</span>

func (_c *MockOrderRepositoryInterface_GetByID_Call) Run(run func(id uint)) *MockOrderRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepositoryInterface_GetByID_Call) Return(_a0 *models.Order, _a1 error) *MockOrderRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockOrderRepositoryInterface_GetByID_Call) RunAndReturn(run func(uint) (*models.Order, error)) *MockOrderRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByUserID provides a mock function with given fields: userID, limit, offset
func (_m *MockOrderRepositoryInterface) GetByUserID(userID uint, limit int, offset int) ([]models.Order, error) <span class="cov0" title="0">{
        ret := _m.Called(userID, limit, offset)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByUserID")</span>
        }

        <span class="cov0" title="0">var r0 []models.Order
        var r1 error
        if rf, ok := ret.Get(0).(func(uint, int, int) ([]models.Order, error)); ok </span><span class="cov0" title="0">{
                return rf(userID, limit, offset)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uint, int, int) []models.Order); ok </span><span class="cov0" title="0">{
                r0 = rf(userID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]models.Order)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uint, int, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(userID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockOrderRepositoryInterface_GetByUserID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUserID'
type MockOrderRepositoryInterface_GetByUserID_Call struct {
        *mock.Call
}

// GetByUserID is a helper method to define mock.On call
//   - userID uint
//   - limit int
//   - offset int
func (_e *MockOrderRepositoryInterface_Expecter) GetByUserID(userID interface{}, limit interface{}, offset interface{}) *MockOrderRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_GetByUserID_Call{Call: _e.mock.On("GetByUserID", userID, limit, offset)}
}</span>

func (_c *MockOrderRepositoryInterface_GetByUserID_Call) Run(run func(userID uint, limit int, offset int)) *MockOrderRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint), args[1].(int), args[2].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepositoryInterface_GetByUserID_Call) Return(_a0 []models.Order, _a1 error) *MockOrderRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockOrderRepositoryInterface_GetByUserID_Call) RunAndReturn(run func(uint, int, int) ([]models.Order, error)) *MockOrderRepositoryInterface_GetByUserID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: order
func (_m *MockOrderRepositoryInterface) Update(order *models.Order) error <span class="cov0" title="0">{
        ret := _m.Called(order)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Order) error); ok </span><span class="cov0" title="0">{
                r0 = rf(order)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockOrderRepositoryInterface_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockOrderRepositoryInterface_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - order *models.Order
func (_e *MockOrderRepositoryInterface_Expecter) Update(order interface{}) *MockOrderRepositoryInterface_Update_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_Update_Call{Call: _e.mock.On("Update", order)}
}</span>

func (_c *MockOrderRepositoryInterface_Update_Call) Run(run func(order *models.Order)) *MockOrderRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Order))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepositoryInterface_Update_Call) Return(_a0 error) *MockOrderRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockOrderRepositoryInterface_Update_Call) RunAndReturn(run func(*models.Order) error) *MockOrderRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateStatus provides a mock function with given fields: id, status
func (_m *MockOrderRepositoryInterface) UpdateStatus(id uint, status models.OrderStatus) error <span class="cov0" title="0">{
        ret := _m.Called(id, status)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateStatus")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint, models.OrderStatus) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id, status)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockOrderRepositoryInterface_UpdateStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStatus'
type MockOrderRepositoryInterface_UpdateStatus_Call struct {
        *mock.Call
}

// UpdateStatus is a helper method to define mock.On call
//   - id uint
//   - status models.OrderStatus
func (_e *MockOrderRepositoryInterface_Expecter) UpdateStatus(id interface{}, status interface{}) *MockOrderRepositoryInterface_UpdateStatus_Call <span class="cov0" title="0">{
        return &amp;MockOrderRepositoryInterface_UpdateStatus_Call{Call: _e.mock.On("UpdateStatus", id, status)}
}</span>

func (_c *MockOrderRepositoryInterface_UpdateStatus_Call) Run(run func(id uint, status models.OrderStatus)) *MockOrderRepositoryInterface_UpdateStatus_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint), args[1].(models.OrderStatus))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockOrderRepositoryInterface_UpdateStatus_Call) Return(_a0 error) *MockOrderRepositoryInterface_UpdateStatus_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockOrderRepositoryInterface_UpdateStatus_Call) RunAndReturn(run func(uint, models.OrderStatus) error) *MockOrderRepositoryInterface_UpdateStatus_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockOrderRepositoryInterface creates a new instance of MockOrderRepositoryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOrderRepositoryInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockOrderRepositoryInterface <span class="cov0" title="0">{
        mock := &amp;MockOrderRepositoryInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
        models "github.com/JihadRinaldi/go-shop/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// MockProductRepositoryInterface is an autogenerated mock type for the ProductRepositoryInterface type
type MockProductRepositoryInterface struct {
        mock.Mock
}

type MockProductRepositoryInterface_Expecter struct {
        mock *mock.Mock
}

func (_m *MockProductRepositoryInterface) EXPECT() *MockProductRepositoryInterface_Expecter <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: product
func (_m *MockProductRepositoryInterface) Create(product *models.Product) error <span class="cov0" title="0">{
        ret := _m.Called(product)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Product) error); ok </span><span class="cov0" title="0">{
                r0 = rf(product)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockProductRepositoryInterface_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockProductRepositoryInterface_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - product *models.Product
func (_e *MockProductRepositoryInterface_Expecter) Create(product interface{}) *MockProductRepositoryInterface_Create_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_Create_Call{Call: _e.mock.On("Create", product)}
}</span>

func (_c *MockProductRepositoryInterface_Create_Call) Run(run func(product *models.Product)) *MockProductRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Product))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_Create_Call) Return(_a0 error) *MockProductRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_Create_Call) RunAndReturn(run func(*models.Product) error) *MockProductRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function with given fields: id
func (_m *MockProductRepositoryInterface) Delete(id uint) error <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockProductRepositoryInterface_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockProductRepositoryInterface_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - id uint
func (_e *MockProductRepositoryInterface_Expecter) Delete(id interface{}) *MockProductRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_Delete_Call{Call: _e.mock.On("Delete", id)}
}</span>

func (_c *MockProductRepositoryInterface_Delete_Call) Run(run func(id uint)) *MockProductRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_Delete_Call) Return(_a0 error) *MockProductRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_Delete_Call) RunAndReturn(run func(uint) error) *MockProductRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetAll provides a mock function with given fields: limit, offset
func (_m *MockProductRepositoryInterface) GetAll(limit int, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        ret := _m.Called(limit, offset)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetAll")</span>
        }

        <span class="cov0" title="0">var r0 []models.Product
        var r1 error
        if rf, ok := ret.Get(0).(func(int, int) ([]models.Product, error)); ok </span><span class="cov0" title="0">{
                return rf(limit, offset)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(int, int) []models.Product); ok </span><span class="cov0" title="0">{
                r0 = rf(limit, offset)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]models.Product)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(int, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepositoryInterface_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockProductRepositoryInterface_GetAll_Call struct {
        *mock.Call
}

// GetAll is a helper method to define mock.On call
//   - limit int
//   - offset int
func (_e *MockProductRepositoryInterface_Expecter) GetAll(limit interface{}, offset interface{}) *MockProductRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_GetAll_Call{Call: _e.mock.On("GetAll", limit, offset)}
}</span>

func (_c *MockProductRepositoryInterface_GetAll_Call) Run(run func(limit int, offset int)) *MockProductRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(int), args[1].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_GetAll_Call) Return(_a0 []models.Product, _a1 error) *MockProductRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_GetAll_Call) RunAndReturn(run func(int, int) ([]models.Product, error)) *MockProductRepositoryInterface_GetAll_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByCategoryID provides a mock function with given fields: categoryID, limit, offset
func (_m *MockProductRepositoryInterface) GetByCategoryID(categoryID uint, limit int, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        ret := _m.Called(categoryID, limit, offset)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByCategoryID")</span>
        }

        <span class="cov0" title="0">var r0 []models.Product
        var r1 error
        if rf, ok := ret.Get(0).(func(uint, int, int) ([]models.Product, error)); ok </span><span class="cov0" title="0">{
                return rf(categoryID, limit, offset)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uint, int, int) []models.Product); ok </span><span class="cov0" title="0">{
                r0 = rf(categoryID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]models.Product)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uint, int, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(categoryID, limit, offset)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepositoryInterface_GetByCategoryID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByCategoryID'
type MockProductRepositoryInterface_GetByCategoryID_Call struct {
        *mock.Call
}

// GetByCategoryID is a helper method to define mock.On call
//   - categoryID uint
//   - limit int
//   - offset int
func (_e *MockProductRepositoryInterface_Expecter) GetByCategoryID(categoryID interface{}, limit interface{}, offset interface{}) *MockProductRepositoryInterface_GetByCategoryID_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_GetByCategoryID_Call{Call: _e.mock.On("GetByCategoryID", categoryID, limit, offset)}
}</span>

func (_c *MockProductRepositoryInterface_GetByCategoryID_Call) Run(run func(categoryID uint, limit int, offset int)) *MockProductRepositoryInterface_GetByCategoryID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint), args[1].(int), args[2].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_GetByCategoryID_Call) Return(_a0 []models.Product, _a1 error) *MockProductRepositoryInterface_GetByCategoryID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_GetByCategoryID_Call) RunAndReturn(run func(uint, int, int) ([]models.Product, error)) *MockProductRepositoryInterface_GetByCategoryID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function with given fields: id
func (_m *MockProductRepositoryInterface) GetByID(id uint) (*models.Product, error) <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.Product
        var r1 error
        if rf, ok := ret.Get(0).(func(uint) (*models.Product, error)); ok </span><span class="cov0" title="0">{
                return rf(id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uint) *models.Product); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Product)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uint) error); ok </span><span class="cov0" title="0">{
                r1 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepositoryInterface_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockProductRepositoryInterface_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - id uint
func (_e *MockProductRepositoryInterface_Expecter) GetByID(id interface{}) *MockProductRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_GetByID_Call{Call: _e.mock.On("GetByID", id)}
}</span>

func (_c *MockProductRepositoryInterface_GetByID_Call) Run(run func(id uint)) *MockProductRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_GetByID_Call) Return(_a0 *models.Product, _a1 error) *MockProductRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_GetByID_Call) RunAndReturn(run func(uint) (*models.Product, error)) *MockProductRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetBySKU provides a mock function with given fields: sku
func (_m *MockProductRepositoryInterface) GetBySKU(sku string) (*models.Product, error) <span class="cov0" title="0">{
        ret := _m.Called(sku)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetBySKU")</span>
        }

        <span class="cov0" title="0">var r0 *models.Product
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*models.Product, error)); ok </span><span class="cov0" title="0">{
                return rf(sku)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *models.Product); ok </span><span class="cov0" title="0">{
                r0 = rf(sku)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.Product)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(sku)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockProductRepositoryInterface_GetBySKU_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBySKU'
type MockProductRepositoryInterface_GetBySKU_Call struct {
        *mock.Call
}

// GetBySKU is a helper method to define mock.On call
//   - sku string
func (_e *MockProductRepositoryInterface_Expecter) GetBySKU(sku interface{}) *MockProductRepositoryInterface_GetBySKU_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_GetBySKU_Call{Call: _e.mock.On("GetBySKU", sku)}
}</span>

func (_c *MockProductRepositoryInterface_GetBySKU_Call) Run(run func(sku string)) *MockProductRepositoryInterface_GetBySKU_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_GetBySKU_Call) Return(_a0 *models.Product, _a1 error) *MockProductRepositoryInterface_GetBySKU_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_GetBySKU_Call) RunAndReturn(run func(string) (*models.Product, error)) *MockProductRepositoryInterface_GetBySKU_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: product
func (_m *MockProductRepositoryInterface) Update(product *models.Product) error <span class="cov0" title="0">{
        ret := _m.Called(product)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Product) error); ok </span><span class="cov0" title="0">{
                r0 = rf(product)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockProductRepositoryInterface_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockProductRepositoryInterface_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - product *models.Product
func (_e *MockProductRepositoryInterface_Expecter) Update(product interface{}) *MockProductRepositoryInterface_Update_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_Update_Call{Call: _e.mock.On("Update", product)}
}</span>

func (_c *MockProductRepositoryInterface_Update_Call) Run(run func(product *models.Product)) *MockProductRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Product))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_Update_Call) Return(_a0 error) *MockProductRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_Update_Call) RunAndReturn(run func(*models.Product) error) *MockProductRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateStock provides a mock function with given fields: id, quantity
func (_m *MockProductRepositoryInterface) UpdateStock(id uint, quantity int) error <span class="cov0" title="0">{
        ret := _m.Called(id, quantity)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateStock")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id, quantity)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockProductRepositoryInterface_UpdateStock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStock'
type MockProductRepositoryInterface_UpdateStock_Call struct {
        *mock.Call
}

// UpdateStock is a helper method to define mock.On call
//   - id uint
//   - quantity int
func (_e *MockProductRepositoryInterface_Expecter) UpdateStock(id interface{}, quantity interface{}) *MockProductRepositoryInterface_UpdateStock_Call <span class="cov0" title="0">{
        return &amp;MockProductRepositoryInterface_UpdateStock_Call{Call: _e.mock.On("UpdateStock", id, quantity)}
}</span>

func (_c *MockProductRepositoryInterface_UpdateStock_Call) Run(run func(id uint, quantity int)) *MockProductRepositoryInterface_UpdateStock_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint), args[1].(int))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockProductRepositoryInterface_UpdateStock_Call) Return(_a0 error) *MockProductRepositoryInterface_UpdateStock_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockProductRepositoryInterface_UpdateStock_Call) RunAndReturn(run func(uint, int) error) *MockProductRepositoryInterface_UpdateStock_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockProductRepositoryInterface creates a new instance of MockProductRepositoryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockProductRepositoryInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockProductRepositoryInterface <span class="cov0" title="0">{
        mock := &amp;MockProductRepositoryInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// MockPublisher is an autogenerated mock type for the Publisher type
type MockPublisher struct {
        mock.Mock
}

type MockPublisher_Expecter struct {
        mock *mock.Mock
}

func (_m *MockPublisher) EXPECT() *MockPublisher_Expecter <span class="cov0" title="0">{
        return &amp;MockPublisher_Expecter{mock: &amp;_m.Mock}
}</span>

// Close provides a mock function with no fields
func (_m *MockPublisher) Close() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Close")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockPublisher_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockPublisher_Close_Call struct {
        *mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockPublisher_Expecter) Close() *MockPublisher_Close_Call <span class="cov0" title="0">{
        return &amp;MockPublisher_Close_Call{Call: _e.mock.On("Close")}
}</span>

func (_c *MockPublisher_Close_Call) Run(run func()) *MockPublisher_Close_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockPublisher_Close_Call) Return(_a0 error) *MockPublisher_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockPublisher_Close_Call) RunAndReturn(run func() error) *MockPublisher_Close_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Publish provides a mock function with given fields: eventType, payload, metadata
func (_m *MockPublisher) Publish(eventType string, payload interface{}, metadata map[string]string) error <span class="cov0" title="0">{
        ret := _m.Called(eventType, payload, metadata)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Publish")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, interface{}, map[string]string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(eventType, payload, metadata)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockPublisher_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type MockPublisher_Publish_Call struct {
        *mock.Call
}

// Publish is a helper method to define mock.On call
//   - eventType string
//   - payload interface{}
//   - metadata map[string]string
func (_e *MockPublisher_Expecter) Publish(eventType interface{}, payload interface{}, metadata interface{}) *MockPublisher_Publish_Call <span class="cov0" title="0">{
        return &amp;MockPublisher_Publish_Call{Call: _e.mock.On("Publish", eventType, payload, metadata)}
}</span>

func (_c *MockPublisher_Publish_Call) Run(run func(eventType string, payload interface{}, metadata map[string]string)) *MockPublisher_Publish_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(interface{}), args[2].(map[string]string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockPublisher_Publish_Call) Return(_a0 error) *MockPublisher_Publish_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockPublisher_Publish_Call) RunAndReturn(run func(string, interface{}, map[string]string) error) *MockPublisher_Publish_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockPublisher creates a new instance of MockPublisher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPublisher(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockPublisher <span class="cov0" title="0">{
        mock := &amp;MockPublisher{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
        multipart "mime/multipart"

        mock "github.com/stretchr/testify/mock"
)

// MockUploadProvider is an autogenerated mock type for the UploadProvider type
type MockUploadProvider struct {
        mock.Mock
}

type MockUploadProvider_Expecter struct {
        mock *mock.Mock
}

func (_m *MockUploadProvider) EXPECT() *MockUploadProvider_Expecter <span class="cov0" title="0">{
        return &amp;MockUploadProvider_Expecter{mock: &amp;_m.Mock}
}</span>

// DeleteFile provides a mock function with given fields: path
func (_m *MockUploadProvider) DeleteFile(path string) error <span class="cov0" title="0">{
        ret := _m.Called(path)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteFile")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(path)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUploadProvider_DeleteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteFile'
type MockUploadProvider_DeleteFile_Call struct {
        *mock.Call
}

// DeleteFile is a helper method to define mock.On call
//   - path string
func (_e *MockUploadProvider_Expecter) DeleteFile(path interface{}) *MockUploadProvider_DeleteFile_Call <span class="cov0" title="0">{
        return &amp;MockUploadProvider_DeleteFile_Call{Call: _e.mock.On("DeleteFile", path)}
}</span>

func (_c *MockUploadProvider_DeleteFile_Call) Run(run func(path string)) *MockUploadProvider_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUploadProvider_DeleteFile_Call) Return(_a0 error) *MockUploadProvider_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUploadProvider_DeleteFile_Call) RunAndReturn(run func(string) error) *MockUploadProvider_DeleteFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UploadFile provides a mock function with given fields: file, path
func (_m *MockUploadProvider) UploadFile(file *multipart.FileHeader, path string) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(file, path)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UploadFile")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(*multipart.FileHeader, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(file, path)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(*multipart.FileHeader, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(file, path)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(*multipart.FileHeader, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(file, path)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUploadProvider_UploadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadFile'
type MockUploadProvider_UploadFile_Call struct {
        *mock.Call
}

// UploadFile is a helper method to define mock.On call
//   - file *multipart.FileHeader
//   - path string
func (_e *MockUploadProvider_Expecter) UploadFile(file interface{}, path interface{}) *MockUploadProvider_UploadFile_Call <span class="cov0" title="0">{
        return &amp;MockUploadProvider_UploadFile_Call{Call: _e.mock.On("UploadFile", file, path)}
}</span>

func (_c *MockUploadProvider_UploadFile_Call) Run(run func(file *multipart.FileHeader, path string)) *MockUploadProvider_UploadFile_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*multipart.FileHeader), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUploadProvider_UploadFile_Call) Return(_a0 string, _a1 error) *MockUploadProvider_UploadFile_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUploadProvider_UploadFile_Call) RunAndReturn(run func(*multipart.FileHeader, string) (string, error)) *MockUploadProvider_UploadFile_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockUploadProvider creates a new instance of MockUploadProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUploadProvider(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockUploadProvider <span class="cov0" title="0">{
        mock := &amp;MockUploadProvider{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
        models "github.com/JihadRinaldi/go-shop/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// MockUploadRepositoryInterface is an autogenerated mock type for the UploadRepositoryInterface type
type MockUploadRepositoryInterface struct {
        mock.Mock
}

type MockUploadRepositoryInterface_Expecter struct {
        mock *mock.Mock
}

func (_m *MockUploadRepositoryInterface) EXPECT() *MockUploadRepositoryInterface_Expecter <span class="cov0" title="0">{
        return &amp;MockUploadRepositoryInterface_Expecter{mock: &amp;_m.Mock}
}</span>

// CreateProductImage provides a mock function with given fields: image
func (_m *MockUploadRepositoryInterface) CreateProductImage(image *models.ProductImage) error <span class="cov0" title="0">{
        ret := _m.Called(image)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateProductImage")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.ProductImage) error); ok </span><span class="cov0" title="0">{
                r0 = rf(image)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUploadRepositoryInterface_CreateProductImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProductImage'
type MockUploadRepositoryInterface_CreateProductImage_Call struct {
        *mock.Call
}

// CreateProductImage is a helper method to define mock.On call
//   - image *models.ProductImage
func (_e *MockUploadRepositoryInterface_Expecter) CreateProductImage(image interface{}) *MockUploadRepositoryInterface_CreateProductImage_Call <span class="cov0" title="0">{
        return &amp;MockUploadRepositoryInterface_CreateProductImage_Call{Call: _e.mock.On("CreateProductImage", image)}
}</span>

func (_c *MockUploadRepositoryInterface_CreateProductImage_Call) Run(run func(image *models.ProductImage)) *MockUploadRepositoryInterface_CreateProductImage_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.ProductImage))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUploadRepositoryInterface_CreateProductImage_Call) Return(_a0 error) *MockUploadRepositoryInterface_CreateProductImage_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUploadRepositoryInterface_CreateProductImage_Call) RunAndReturn(run func(*models.ProductImage) error) *MockUploadRepositoryInterface_CreateProductImage_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteProductImage provides a mock function with given fields: id
func (_m *MockUploadRepositoryInterface) DeleteProductImage(id uint) error <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteProductImage")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUploadRepositoryInterface_DeleteProductImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProductImage'
type MockUploadRepositoryInterface_DeleteProductImage_Call struct {
        *mock.Call
}

// DeleteProductImage is a helper method to define mock.On call
//   - id uint
func (_e *MockUploadRepositoryInterface_Expecter) DeleteProductImage(id interface{}) *MockUploadRepositoryInterface_DeleteProductImage_Call <span class="cov0" title="0">{
        return &amp;MockUploadRepositoryInterface_DeleteProductImage_Call{Call: _e.mock.On("DeleteProductImage", id)}
}</span>

func (_c *MockUploadRepositoryInterface_DeleteProductImage_Call) Run(run func(id uint)) *MockUploadRepositoryInterface_DeleteProductImage_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUploadRepositoryInterface_DeleteProductImage_Call) Return(_a0 error) *MockUploadRepositoryInterface_DeleteProductImage_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUploadRepositoryInterface_DeleteProductImage_Call) RunAndReturn(run func(uint) error) *MockUploadRepositoryInterface_DeleteProductImage_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetProductImages provides a mock function with given fields: productID
func (_m *MockUploadRepositoryInterface) GetProductImages(productID uint) ([]models.ProductImage, error) <span class="cov0" title="0">{
        ret := _m.Called(productID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetProductImages")</span>
        }

        <span class="cov0" title="0">var r0 []models.ProductImage
        var r1 error
        if rf, ok := ret.Get(0).(func(uint) ([]models.ProductImage, error)); ok </span><span class="cov0" title="0">{
                return rf(productID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uint) []models.ProductImage); ok </span><span class="cov0" title="0">{
                r0 = rf(productID)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]models.ProductImage)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uint) error); ok </span><span class="cov0" title="0">{
                r1 = rf(productID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUploadRepositoryInterface_GetProductImages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProductImages'
type MockUploadRepositoryInterface_GetProductImages_Call struct {
        *mock.Call
}

// GetProductImages is a helper method to define mock.On call
//   - productID uint
func (_e *MockUploadRepositoryInterface_Expecter) GetProductImages(productID interface{}) *MockUploadRepositoryInterface_GetProductImages_Call <span class="cov0" title="0">{
        return &amp;MockUploadRepositoryInterface_GetProductImages_Call{Call: _e.mock.On("GetProductImages", productID)}
}</span>

func (_c *MockUploadRepositoryInterface_GetProductImages_Call) Run(run func(productID uint)) *MockUploadRepositoryInterface_GetProductImages_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUploadRepositoryInterface_GetProductImages_Call) Return(_a0 []models.ProductImage, _a1 error) *MockUploadRepositoryInterface_GetProductImages_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUploadRepositoryInterface_GetProductImages_Call) RunAndReturn(run func(uint) ([]models.ProductImage, error)) *MockUploadRepositoryInterface_GetProductImages_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SetPrimaryImage provides a mock function with given fields: productID, imageID
func (_m *MockUploadRepositoryInterface) SetPrimaryImage(productID uint, imageID uint) error <span class="cov0" title="0">{
        ret := _m.Called(productID, imageID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SetPrimaryImage")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint, uint) error); ok </span><span class="cov0" title="0">{
                r0 = rf(productID, imageID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUploadRepositoryInterface_SetPrimaryImage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPrimaryImage'
type MockUploadRepositoryInterface_SetPrimaryImage_Call struct {
        *mock.Call
}

// SetPrimaryImage is a helper method to define mock.On call
//   - productID uint
//   - imageID uint
func (_e *MockUploadRepositoryInterface_Expecter) SetPrimaryImage(productID interface{}, imageID interface{}) *MockUploadRepositoryInterface_SetPrimaryImage_Call <span class="cov0" title="0">{
        return &amp;MockUploadRepositoryInterface_SetPrimaryImage_Call{Call: _e.mock.On("SetPrimaryImage", productID, imageID)}
}</span>

func (_c *MockUploadRepositoryInterface_SetPrimaryImage_Call) Run(run func(productID uint, imageID uint)) *MockUploadRepositoryInterface_SetPrimaryImage_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint), args[1].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUploadRepositoryInterface_SetPrimaryImage_Call) Return(_a0 error) *MockUploadRepositoryInterface_SetPrimaryImage_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUploadRepositoryInterface_SetPrimaryImage_Call) RunAndReturn(run func(uint, uint) error) *MockUploadRepositoryInterface_SetPrimaryImage_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockUploadRepositoryInterface creates a new instance of MockUploadRepositoryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUploadRepositoryInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockUploadRepositoryInterface <span class="cov0" title="0">{
        mock := &amp;MockUploadRepositoryInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
        models "github.com/JihadRinaldi/go-shop/internal/models"
        mock "github.com/stretchr/testify/mock"
)

// MockUserRepositoryInterface is an autogenerated mock type for the UserRepositoryInterface type
type MockUserRepositoryInterface struct {
        mock.Mock
}

type MockUserRepositoryInterface_Expecter struct {
        mock *mock.Mock
}

func (_m *MockUserRepositoryInterface) EXPECT() *MockUserRepositoryInterface_Expecter <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_Expecter{mock: &amp;_m.Mock}
}</span>

// Create provides a mock function with given fields: user
func (_m *MockUserRepositoryInterface) Create(user *models.User) error <span class="cov0" title="0">{
        ret := _m.Called(user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Create")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepositoryInterface_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepositoryInterface_Create_Call struct {
        *mock.Call
}

// Create is a helper method to define mock.On call
//   - user *models.User
func (_e *MockUserRepositoryInterface_Expecter) Create(user interface{}) *MockUserRepositoryInterface_Create_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_Create_Call{Call: _e.mock.On("Create", user)}
}</span>

func (_c *MockUserRepositoryInterface_Create_Call) Run(run func(user *models.User)) *MockUserRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_Create_Call) Return(_a0 error) *MockUserRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_Create_Call) RunAndReturn(run func(*models.User) error) *MockUserRepositoryInterface_Create_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CreateRefreshToken provides a mock function with given fields: token
func (_m *MockUserRepositoryInterface) CreateRefreshToken(token *models.RefreshToken) error <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CreateRefreshToken")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.RefreshToken) error); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepositoryInterface_CreateRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRefreshToken'
type MockUserRepositoryInterface_CreateRefreshToken_Call struct {
        *mock.Call
}

// CreateRefreshToken is a helper method to define mock.On call
//   - token *models.RefreshToken
func (_e *MockUserRepositoryInterface_Expecter) CreateRefreshToken(token interface{}) *MockUserRepositoryInterface_CreateRefreshToken_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_CreateRefreshToken_Call{Call: _e.mock.On("CreateRefreshToken", token)}
}</span>

func (_c *MockUserRepositoryInterface_CreateRefreshToken_Call) Run(run func(token *models.RefreshToken)) *MockUserRepositoryInterface_CreateRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.RefreshToken))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_CreateRefreshToken_Call) Return(_a0 error) *MockUserRepositoryInterface_CreateRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_CreateRefreshToken_Call) RunAndReturn(run func(*models.RefreshToken) error) *MockUserRepositoryInterface_CreateRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Delete provides a mock function with given fields: id
func (_m *MockUserRepositoryInterface) Delete(id uint) error <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Delete")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepositoryInterface_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockUserRepositoryInterface_Delete_Call struct {
        *mock.Call
}

// Delete is a helper method to define mock.On call
//   - id uint
func (_e *MockUserRepositoryInterface_Expecter) Delete(id interface{}) *MockUserRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_Delete_Call{Call: _e.mock.On("Delete", id)}
}</span>

func (_c *MockUserRepositoryInterface_Delete_Call) Run(run func(id uint)) *MockUserRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_Delete_Call) Return(_a0 error) *MockUserRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_Delete_Call) RunAndReturn(run func(uint) error) *MockUserRepositoryInterface_Delete_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteRefreshToken provides a mock function with given fields: token
func (_m *MockUserRepositoryInterface) DeleteRefreshToken(token string) error <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteRefreshToken")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepositoryInterface_DeleteRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRefreshToken'
type MockUserRepositoryInterface_DeleteRefreshToken_Call struct {
        *mock.Call
}

// DeleteRefreshToken is a helper method to define mock.On call
//   - token string
func (_e *MockUserRepositoryInterface_Expecter) DeleteRefreshToken(token interface{}) *MockUserRepositoryInterface_DeleteRefreshToken_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_DeleteRefreshToken_Call{Call: _e.mock.On("DeleteRefreshToken", token)}
}</span>

func (_c *MockUserRepositoryInterface_DeleteRefreshToken_Call) Run(run func(token string)) *MockUserRepositoryInterface_DeleteRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_DeleteRefreshToken_Call) Return(_a0 error) *MockUserRepositoryInterface_DeleteRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_DeleteRefreshToken_Call) RunAndReturn(run func(string) error) *MockUserRepositoryInterface_DeleteRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// DeleteRefreshTokenByID provides a mock function with given fields: id
func (_m *MockUserRepositoryInterface) DeleteRefreshTokenByID(id uint) error <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteRefreshTokenByID")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(uint) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepositoryInterface_DeleteRefreshTokenByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRefreshTokenByID'
type MockUserRepositoryInterface_DeleteRefreshTokenByID_Call struct {
        *mock.Call
}

// DeleteRefreshTokenByID is a helper method to define mock.On call
//   - id uint
func (_e *MockUserRepositoryInterface_Expecter) DeleteRefreshTokenByID(id interface{}) *MockUserRepositoryInterface_DeleteRefreshTokenByID_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_DeleteRefreshTokenByID_Call{Call: _e.mock.On("DeleteRefreshTokenByID", id)}
}</span>

func (_c *MockUserRepositoryInterface_DeleteRefreshTokenByID_Call) Run(run func(id uint)) *MockUserRepositoryInterface_DeleteRefreshTokenByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_DeleteRefreshTokenByID_Call) Return(_a0 error) *MockUserRepositoryInterface_DeleteRefreshTokenByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_DeleteRefreshTokenByID_Call) RunAndReturn(run func(uint) error) *MockUserRepositoryInterface_DeleteRefreshTokenByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByEmail provides a mock function with given fields: email
func (_m *MockUserRepositoryInterface) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(email)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByEmail")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(email)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(email)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(email)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepositoryInterface_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockUserRepositoryInterface_GetByEmail_Call struct {
        *mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - email string
func (_e *MockUserRepositoryInterface_Expecter) GetByEmail(email interface{}) *MockUserRepositoryInterface_GetByEmail_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_GetByEmail_Call{Call: _e.mock.On("GetByEmail", email)}
}</span>

func (_c *MockUserRepositoryInterface_GetByEmail_Call) Run(run func(email string)) *MockUserRepositoryInterface_GetByEmail_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_GetByEmail_Call) Return(_a0 *models.User, _a1 error) *MockUserRepositoryInterface_GetByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_GetByEmail_Call) RunAndReturn(run func(string) (*models.User, error)) *MockUserRepositoryInterface_GetByEmail_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByEmailAndActive provides a mock function with given fields: email, isActive
func (_m *MockUserRepositoryInterface) GetByEmailAndActive(email string, isActive bool) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(email, isActive)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByEmailAndActive")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(string, bool) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(email, isActive)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string, bool) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(email, isActive)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string, bool) error); ok </span><span class="cov0" title="0">{
                r1 = rf(email, isActive)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepositoryInterface_GetByEmailAndActive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmailAndActive'
type MockUserRepositoryInterface_GetByEmailAndActive_Call struct {
        *mock.Call
}

// GetByEmailAndActive is a helper method to define mock.On call
//   - email string
//   - isActive bool
func (_e *MockUserRepositoryInterface_Expecter) GetByEmailAndActive(email interface{}, isActive interface{}) *MockUserRepositoryInterface_GetByEmailAndActive_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_GetByEmailAndActive_Call{Call: _e.mock.On("GetByEmailAndActive", email, isActive)}
}</span>

func (_c *MockUserRepositoryInterface_GetByEmailAndActive_Call) Run(run func(email string, isActive bool)) *MockUserRepositoryInterface_GetByEmailAndActive_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(bool))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_GetByEmailAndActive_Call) Return(_a0 *models.User, _a1 error) *MockUserRepositoryInterface_GetByEmailAndActive_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_GetByEmailAndActive_Call) RunAndReturn(run func(string, bool) (*models.User, error)) *MockUserRepositoryInterface_GetByEmailAndActive_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetByID provides a mock function with given fields: id
func (_m *MockUserRepositoryInterface) GetByID(id uint) (*models.User, error) <span class="cov0" title="0">{
        ret := _m.Called(id)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetByID")</span>
        }

        <span class="cov0" title="0">var r0 *models.User
        var r1 error
        if rf, ok := ret.Get(0).(func(uint) (*models.User, error)); ok </span><span class="cov0" title="0">{
                return rf(id)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(uint) *models.User); ok </span><span class="cov0" title="0">{
                r0 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.User)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(uint) error); ok </span><span class="cov0" title="0">{
                r1 = rf(id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepositoryInterface_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockUserRepositoryInterface_GetByID_Call struct {
        *mock.Call
}

// GetByID is a helper method to define mock.On call
//   - id uint
func (_e *MockUserRepositoryInterface_Expecter) GetByID(id interface{}) *MockUserRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_GetByID_Call{Call: _e.mock.On("GetByID", id)}
}</span>

func (_c *MockUserRepositoryInterface_GetByID_Call) Run(run func(id uint)) *MockUserRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(uint))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_GetByID_Call) Return(_a0 *models.User, _a1 error) *MockUserRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_GetByID_Call) RunAndReturn(run func(uint) (*models.User, error)) *MockUserRepositoryInterface_GetByID_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetValidRefreshToken provides a mock function with given fields: token
func (_m *MockUserRepositoryInterface) GetValidRefreshToken(token string) (*models.RefreshToken, error) <span class="cov0" title="0">{
        ret := _m.Called(token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetValidRefreshToken")</span>
        }

        <span class="cov0" title="0">var r0 *models.RefreshToken
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*models.RefreshToken, error)); ok </span><span class="cov0" title="0">{
                return rf(token)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) *models.RefreshToken); ok </span><span class="cov0" title="0">{
                r0 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*models.RefreshToken)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(token)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockUserRepositoryInterface_GetValidRefreshToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValidRefreshToken'
type MockUserRepositoryInterface_GetValidRefreshToken_Call struct {
        *mock.Call
}

// GetValidRefreshToken is a helper method to define mock.On call
//   - token string
func (_e *MockUserRepositoryInterface_Expecter) GetValidRefreshToken(token interface{}) *MockUserRepositoryInterface_GetValidRefreshToken_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_GetValidRefreshToken_Call{Call: _e.mock.On("GetValidRefreshToken", token)}
}</span>

func (_c *MockUserRepositoryInterface_GetValidRefreshToken_Call) Run(run func(token string)) *MockUserRepositoryInterface_GetValidRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_GetValidRefreshToken_Call) Return(_a0 *models.RefreshToken, _a1 error) *MockUserRepositoryInterface_GetValidRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_GetValidRefreshToken_Call) RunAndReturn(run func(string) (*models.RefreshToken, error)) *MockUserRepositoryInterface_GetValidRefreshToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Update provides a mock function with given fields: user
func (_m *MockUserRepositoryInterface) Update(user *models.User) error <span class="cov0" title="0">{
        ret := _m.Called(user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Update")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(*models.User) error); ok </span><span class="cov0" title="0">{
                r0 = rf(user)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockUserRepositoryInterface_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockUserRepositoryInterface_Update_Call struct {
        *mock.Call
}

// Update is a helper method to define mock.On call
//   - user *models.User
func (_e *MockUserRepositoryInterface_Expecter) Update(user interface{}) *MockUserRepositoryInterface_Update_Call <span class="cov0" title="0">{
        return &amp;MockUserRepositoryInterface_Update_Call{Call: _e.mock.On("Update", user)}
}</span>

func (_c *MockUserRepositoryInterface_Update_Call) Run(run func(user *models.User)) *MockUserRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.User))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockUserRepositoryInterface_Update_Call) Return(_a0 error) *MockUserRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockUserRepositoryInterface_Update_Call) RunAndReturn(run func(*models.User) error) *MockUserRepositoryInterface_Update_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockUserRepositoryInterface creates a new instance of MockUserRepositoryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepositoryInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockUserRepositoryInterface <span class="cov0" title="0">{
        mock := &amp;MockUserRepositoryInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package notifications

import (
        "fmt"
        "net"
        "net/smtp"
        "strconv"
)

type SMTPConfig struct {
        Host     string
        Port     int
        Username string
        Password string
        From     string
}

type EmailConfig struct {
        To      string
        Subject string
        Body    string
}

type EmailNotifier struct {
        config *SMTPConfig
}

func NewEmailNotifier(config *SMTPConfig) *EmailNotifier <span class="cov0" title="0">{
        return &amp;EmailNotifier{config: config}
}</span>

func (n *EmailNotifier) SendEmail(emailConfig *EmailConfig) error <span class="cov0" title="0">{
        addr := net.JoinHostPort(n.config.Host, strconv.Itoa(n.config.Port))

        conn, err := net.Dial("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        client, err := smtp.NewClient(conn, n.config.Host)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer client.Close()

        if n.config.Username != "" &amp;&amp; n.config.Password != "" </span><span class="cov0" title="0">{
                auth := smtp.PlainAuth("", n.config.Username, n.config.Password, n.config.Host)
                if err = client.Auth(auth); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := client.Mail(n.config.From); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := client.Rcpt(emailConfig.To); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">w, err := client.Data()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">msg := fmt.Sprintf("From: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n%s",
                n.config.From, emailConfig.To, emailConfig.Subject, emailConfig.Body)

        _, err = w.Write([]byte(msg))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return w.Close()</span>
}

func (e *EmailNotifier) SendLoginNotification(userEmail, userName string) error <span class="cov0" title="0">{
        email := &amp;EmailConfig{
                To:      userEmail,
                Subject: "Login Notification",
                Body: fmt.Sprintf(`Hello %s,

You have successfully logged into your account.

If this wasn't you, please contact support immediately.

Best regards,
The Shop Team`, userName),
        }

        return e.SendEmail(email)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package providers

import (
        "context"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
)

func CreateAWSConfig(ctx context.Context, endpoint, region string) (aws.Config, error) <span class="cov0" title="0">{
        var cfg aws.Config
        var err error

        if endpoint != "" </span><span class="cov0" title="0">{
                cfg, err = config.LoadDefaultConfig(ctx, config.WithRegion(region),
                        config.WithBaseEndpoint(endpoint), config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                                "test",
                                "test",
                                "",
                        )),
                )

        }</span> else<span class="cov0" title="0"> {
                cfg, err = config.LoadDefaultConfig(ctx, config.WithRegion(region))
        }</span>

        <span class="cov0" title="0">return cfg, err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package providers

import (
        "fmt"
        "mime/multipart"
        "os"
        "path/filepath"
)

type LocalUploadProvider struct {
        basePath string
}

func NewLocalUploadProvider(basePath string) *LocalUploadProvider <span class="cov0" title="0">{
        return &amp;LocalUploadProvider{basePath: basePath}
}</span>

func (p *LocalUploadProvider) UploadFile(fileHeader *multipart.FileHeader, path string) (string, error) <span class="cov0" title="0">{
        fullPath := filepath.Join(p.basePath, path)

        if err := os.MkdirAll(filepath.Dir(fullPath), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Open the uploaded file
        <span class="cov0" title="0">src, err := fileHeader.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer src.Close()

        // Create the destination file
        dst, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        // Read from source and write to destination
        if _, err := dst.ReadFrom(src); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("/uploads/%s", path), nil</span>
}

func (p *LocalUploadProvider) DeleteFile(path string) error <span class="cov0" title="0">{
        fullPath := filepath.Join(p.basePath, path)
        return os.Remove(fullPath)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package providers

import (
        "context"
        "mime/multipart"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/feature/s3/manager"
        "github.com/aws/aws-sdk-go-v2/service/s3"

        appConfig "github.com/JihadRinaldi/go-shop/internal/config"
)

type S3Provider struct {
        client   *s3.Client
        uploader *manager.Uploader
        bucket   string
        endpoint string
}

func NewS3Provider(cfg *appConfig.Config) *S3Provider <span class="cov0" title="0">{
        awsCfg, err := config.LoadDefaultConfig(context.TODO(),
                config.WithRegion(cfg.AWS.Region),
                config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        cfg.AWS.AccessKeyID,
                        cfg.AWS.SecretAccessKey,
                        "",
                )),
        )

        if err != nil </span><span class="cov0" title="0">{
                panic("failed to create AWS config " + err.Error())</span>
        }

        // Configure for localstack
        <span class="cov0" title="0">client := s3.NewFromConfig(awsCfg, func(o *s3.Options) </span><span class="cov0" title="0">{
                if cfg.AWS.S3Endpoint != "" </span><span class="cov0" title="0">{
                        o.BaseEndpoint = aws.String(cfg.AWS.S3Endpoint)
                        o.UsePathStyle = true
                }</span>
        })

        <span class="cov0" title="0">return &amp;S3Provider{
                client:   client,
                uploader: manager.NewUploader(client),
                bucket:   cfg.AWS.S3Bucket,
                endpoint: cfg.AWS.S3Endpoint,
        }</span>
}

func (p *S3Provider) UploadFile(file *multipart.FileHeader, path string) (string, error) <span class="cov0" title="0">{
        src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer src.Close()

        result, err := p.uploader.Upload(context.TODO(), &amp;s3.PutObjectInput{
                Bucket: aws.String(p.bucket),
                Key:    aws.String(path),
                Body:   src,
        })

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return *result.Key, nil</span>
}

func (p *S3Provider) DeleteFile(path string) error <span class="cov0" title="0">{
        _, err := p.client.DeleteObject(context.TODO(), &amp;s3.DeleteObjectInput{
                Bucket: aws.String(p.bucket),
                Key:    aws.String(path),
        })

        return err
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repositories

import (
        "github.com/JihadRinaldi/go-shop/internal/models"
        "gorm.io/gorm"
)

type CartRepository struct {
        db *gorm.DB
}

func NewCartRepository(db *gorm.DB) *CartRepository <span class="cov0" title="0">{
        return &amp;CartRepository{db: db}
}</span>

func (r *CartRepository) GetByUserID(userID uint) (*models.Cart, error) <span class="cov0" title="0">{
        var cart models.Cart
        if err := r.db.Where("user_id = ?", userID).First(&amp;cart).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cart, nil</span>
}
func (r *CartRepository) Create(cart *models.Cart) error <span class="cov0" title="0">{
        return r.db.Create(cart).Error
}</span>
func (r *CartRepository) Update(cart *models.Cart) error <span class="cov0" title="0">{
        return r.db.Save(cart).Error
}</span>
func (r *CartRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.Cart{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package repositories

import (
        "github.com/JihadRinaldi/go-shop/internal/models"
        "gorm.io/gorm"
)

type OrderRepository struct {
        db *gorm.DB
}

func NewOrderRepository(db *gorm.DB) *OrderRepository <span class="cov0" title="0">{
        return &amp;OrderRepository{db: db}
}</span>

func (r *OrderRepository) GetByID(id uint) (*models.Order, error) <span class="cov0" title="0">{
        var order models.Order
        if err := r.db.Preload("User").Preload("OrderItems.Product").First(&amp;order, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;order, nil</span>
}

func (r *OrderRepository) GetByUserID(userID uint, limit, offset int) ([]models.Order, error) <span class="cov0" title="0">{
        var orders []models.Order
        query := r.db.Preload("OrderItems.Product").Where("user_id = ?", userID)

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(limit)
        }</span>
        <span class="cov0" title="0">if offset &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset(offset)
        }</span>

        <span class="cov0" title="0">if err := query.Order("created_at DESC").Find(&amp;orders).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

func (r *OrderRepository) GetAll(limit, offset int) ([]models.Order, error) <span class="cov0" title="0">{
        var orders []models.Order
        query := r.db.Preload("User").Preload("OrderItems.Product")

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(limit)
        }</span>
        <span class="cov0" title="0">if offset &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset(offset)
        }</span>

        <span class="cov0" title="0">if err := query.Order("created_at DESC").Find(&amp;orders).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

func (r *OrderRepository) Create(order *models.Order) error <span class="cov0" title="0">{
        return r.db.Create(order).Error
}</span>

func (r *OrderRepository) Update(order *models.Order) error <span class="cov0" title="0">{
        return r.db.Save(order).Error
}</span>

func (r *OrderRepository) UpdateStatus(id uint, status models.OrderStatus) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.Order{}).Where("id = ?", id).Update("status", status).Error
}</span>

func (r *OrderRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.Order{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package repositories

import (
        "github.com/JihadRinaldi/go-shop/internal/models"
        "gorm.io/gorm"
)

type ProductRepository struct {
        db *gorm.DB
}

func NewProductRepository(db *gorm.DB) *ProductRepository <span class="cov0" title="0">{
        return &amp;ProductRepository{db: db}
}</span>

func (r *ProductRepository) GetByID(id uint) (*models.Product, error) <span class="cov0" title="0">{
        var product models.Product
        if err := r.db.Preload("Category").Preload("Images").First(&amp;product, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;product, nil</span>
}

func (r *ProductRepository) GetAll(limit, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        query := r.db.Preload("Category").Preload("Images")

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(limit)
        }</span>
        <span class="cov0" title="0">if offset &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset(offset)
        }</span>

        <span class="cov0" title="0">if err := query.Find(&amp;products).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

func (r *ProductRepository) GetByCategoryID(categoryID uint, limit, offset int) ([]models.Product, error) <span class="cov0" title="0">{
        var products []models.Product
        query := r.db.Preload("Category").Preload("Images").Where("category_id = ?", categoryID)

        if limit &gt; 0 </span><span class="cov0" title="0">{
                query = query.Limit(limit)
        }</span>
        <span class="cov0" title="0">if offset &gt; 0 </span><span class="cov0" title="0">{
                query = query.Offset(offset)
        }</span>

        <span class="cov0" title="0">if err := query.Find(&amp;products).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return products, nil</span>
}

func (r *ProductRepository) GetBySKU(sku string) (*models.Product, error) <span class="cov0" title="0">{
        var product models.Product
        if err := r.db.Preload("Category").Preload("Images").Where("sku = ?", sku).First(&amp;product).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;product, nil</span>
}

func (r *ProductRepository) Create(product *models.Product) error <span class="cov0" title="0">{
        return r.db.Create(product).Error
}</span>

func (r *ProductRepository) Update(product *models.Product) error <span class="cov0" title="0">{
        return r.db.Save(product).Error
}</span>

func (r *ProductRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.Product{}, id).Error
}</span>

func (r *ProductRepository) UpdateStock(id uint, quantity int) error <span class="cov0" title="0">{
        return r.db.Model(&amp;models.Product{}).Where("id = ?", id).Update("stock", quantity).Error
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package repositories

import (
        "github.com/JihadRinaldi/go-shop/internal/models"
        "gorm.io/gorm"
)

type UploadRepository struct {
        db *gorm.DB
}

func NewUploadRepository(db *gorm.DB) *UploadRepository <span class="cov0" title="0">{
        return &amp;UploadRepository{db: db}
}</span>

func (r *UploadRepository) CreateProductImage(image *models.ProductImage) error <span class="cov0" title="0">{
        return r.db.Create(image).Error
}</span>

func (r *UploadRepository) GetProductImages(productID uint) ([]models.ProductImage, error) <span class="cov0" title="0">{
        var images []models.ProductImage
        if err := r.db.Where("product_id = ?", productID).Order("is_primary DESC, created_at ASC").Find(&amp;images).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return images, nil</span>
}

func (r *UploadRepository) DeleteProductImage(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.ProductImage{}, id).Error
}</span>

func (r *UploadRepository) SetPrimaryImage(productID, imageID uint) error <span class="cov0" title="0">{
        return r.db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                // Set all images for this product to non-primary
                if err := tx.Model(&amp;models.ProductImage{}).Where("product_id = ?", productID).Update("is_primary", false).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Set the specified image as primary
                <span class="cov0" title="0">if err := tx.Model(&amp;models.ProductImage{}).Where("id = ? AND product_id = ?", imageID, productID).Update("is_primary", true).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repositories

import (
        "time"

        "github.com/JihadRinaldi/go-shop/internal/models"
        "gorm.io/gorm"
)

type UserRepository struct {
        db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{db: db}
}</span>

func (r *UserRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        if err := r.db.Where("email = ?", email).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *UserRepository) GetByID(id uint) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        if err := r.db.First(&amp;user, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *UserRepository) GetByEmailAndActive(email string, isActive bool) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        if err := r.db.Where("email = ? AND is_active = ?", email, isActive).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *UserRepository) Create(user *models.User) error <span class="cov0" title="0">{
        return r.db.Create(user).Error
}</span>

func (r *UserRepository) Update(user *models.User) error <span class="cov0" title="0">{
        return r.db.Save(user).Error
}</span>

func (r *UserRepository) Delete(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.User{}, id).Error
}</span>

func (r *UserRepository) CreateRefreshToken(token *models.RefreshToken) error <span class="cov0" title="0">{
        return r.db.Create(token).Error
}</span>

func (r *UserRepository) GetValidRefreshToken(token string) (*models.RefreshToken, error) <span class="cov0" title="0">{
        var refreshToken models.RefreshToken
        if err := r.db.Where("token = ? AND expires_at &gt; ?", token, time.Now()).First(&amp;refreshToken).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;refreshToken, nil</span>
}

func (r *UserRepository) DeleteRefreshToken(token string) error <span class="cov0" title="0">{
        return r.db.Where("token = ?", token).Delete(&amp;models.RefreshToken{}).Error
}</span>

func (r *UserRepository) DeleteRefreshTokenByID(id uint) error <span class="cov0" title="0">{
        return r.db.Delete(&amp;models.RefreshToken{}, id).Error
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package server

import (
        "strings"

        "github.com/JihadRinaldi/go-shop/internal/models"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "github.com/gin-gonic/gin"
)

const (
        AuthorizationHeader = "Authorization"
        AuthorizationBearer = "Bearer"
)

func (s *Server) authMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                authHeader := ctx.GetHeader(AuthorizationHeader)
                if authHeader == "" </span><span class="cov0" title="0">{
                        utils.UnauthorizedResponse(ctx, "Authorization header required")
                        ctx.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := strings.Split(authHeader, " ")
                if len(tokenString) != 2 || tokenString[0] != AuthorizationBearer </span><span class="cov0" title="0">{
                        utils.UnauthorizedResponse(ctx, "Authorization header required")
                        ctx.Abort()
                        return
                }</span>

                <span class="cov0" title="0">claims, err := utils.ValidateToken(tokenString[1], s.config.JWT.SecretKey)
                if err != nil </span><span class="cov0" title="0">{
                        utils.UnauthorizedResponse(ctx, "Authorization header required")
                        ctx.Abort()
                        return
                }</span>

                <span class="cov0" title="0">ctx.Set("user_id", claims.UserID)
                ctx.Set("user_email", claims.Email)
                ctx.Set("user_role", claims.Role)

                ctx.Next()</span>
        }
}

func (s *Server) adminMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(ctx *gin.Context) </span><span class="cov0" title="0">{
                role, exists := ctx.Get("user_role")
                if !exists || role != string(models.UserRoleAdmin) </span><span class="cov0" title="0">{
                        utils.ForbiddenResponse(ctx, "Admin access required")
                        ctx.Abort()
                        return
                }</span>

                <span class="cov0" title="0">ctx.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package server

import (
        "context"
        "net/http"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/events"
        "github.com/JihadRinaldi/go-shop/internal/handler"
        "github.com/JihadRinaldi/go-shop/internal/interfaces"
        "github.com/JihadRinaldi/go-shop/internal/providers"
        "github.com/JihadRinaldi/go-shop/internal/services"
        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog"
        "gorm.io/gorm"
)

type Server struct {
        config         *config.Config
        db             *gorm.DB
        logger         zerolog.Logger
        authHandler    *handler.AuthHandler
        userHandler    *handler.UserHandler
        productHandler *handler.ProductHandler
        cartHandler    *handler.CartHandler
        orderHandler   *handler.OrderHandler
}

func New(cfg *config.Config, db *gorm.DB, logger *zerolog.Logger) *Server <span class="cov0" title="0">{
        var uploadProvider interfaces.UploadProvider
        if cfg.Upload.UploadProvider == "s3" </span><span class="cov0" title="0">{
                uploadProvider = providers.NewS3Provider(cfg)
        }</span> else<span class="cov0" title="0"> {
                uploadProvider = providers.NewLocalUploadProvider(cfg.Upload.Path)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        eventPublisher, err := events.NewEventPublisher(ctx, cfg.AWS)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal().Err(err).Msg("Failed to create event publisher")
                return nil
        }</span>

        <span class="cov0" title="0">authService := services.NewAuthService(db, cfg, eventPublisher)
        userService := services.NewUserService(db, cfg)
        productService := services.NewProductService(db, cfg)
        uploadService := services.NewUploadService(db, uploadProvider)
        cartService := services.NewCartService(db, cfg)
        orderService := services.NewOrderService(db, cfg)

        authHandler := handler.NewAuthHandler(authService)
        userHandler := handler.NewUserHandler(userService)
        productHandler := handler.NewProductHandler(productService, uploadService)
        cartHandler := handler.NewCartHandler(cartService)
        orderHandler := handler.NewOrderHandler(orderService)

        return &amp;Server{
                config:         cfg,
                db:             db,
                logger:         *logger,
                authHandler:    authHandler,
                userHandler:    userHandler,
                productHandler: productHandler,
                cartHandler:    cartHandler,
                orderHandler:   orderHandler,
        }</span>
}

func (s *Server) SetupRoutes() *gin.Engine <span class="cov0" title="0">{
        router := gin.New()

        router.Use(gin.Logger())
        router.Use(gin.Recovery())
        router.Use(s.corsMiddleware())

        router.GET("/healthz", s.healthCheck)

        api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                auth := api.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/register", s.authHandler.Register)
                        auth.POST("/login", s.authHandler.Login)
                        auth.POST("/refresh", s.authHandler.RefreshToken)
                        auth.POST("/logout", s.authHandler.Logout)
                }</span>

                <span class="cov0" title="0">protected := api.Group("/")
                protected.Use(s.authMiddleware())
                </span><span class="cov0" title="0">{
                        user := protected.Group("/user")
                        </span><span class="cov0" title="0">{
                                user.GET("/profile", s.userHandler.GetProfile)
                                user.PUT("/profile", s.userHandler.UpdateProfile)
                        }</span>

                        <span class="cov0" title="0">categories := protected.Group("/categories")
                        </span><span class="cov0" title="0">{
                                categories.POST("/", s.adminMiddleware(), s.productHandler.CreateCategory)
                                categories.PUT("/:id", s.adminMiddleware(), s.productHandler.UpdateCategory)
                                categories.DELETE("/:id", s.adminMiddleware(), s.productHandler.DeleteCategory)
                        }</span>

                        <span class="cov0" title="0">products := protected.Group("/products")
                        </span><span class="cov0" title="0">{

                                products.POST("/", s.adminMiddleware(), s.productHandler.CreateProduct)
                                products.PUT("/:id", s.adminMiddleware(), s.productHandler.UpdateProduct)
                                products.DELETE("/:id", s.adminMiddleware(), s.productHandler.DeleteProduct)
                                products.POST("/:id/images", s.adminMiddleware(), s.productHandler.UploadProductImage)
                        }</span>

                        <span class="cov0" title="0">carts := protected.Group("/carts")
                        </span><span class="cov0" title="0">{
                                carts.GET("/", s.cartHandler.GetCart)
                                carts.POST("/items", s.cartHandler.AddToCart)
                                carts.PUT("/items/:id", s.cartHandler.UpdateCartItem)
                                carts.DELETE("/items/:id", s.cartHandler.RemoveCartItem)
                        }</span>

                        <span class="cov0" title="0">orders := protected.Group("/orders")
                        </span><span class="cov0" title="0">{
                                orders.POST("/", s.orderHandler.CreateOrder)
                                orders.GET("/:id", s.orderHandler.GetOrder)
                                orders.GET("/", s.orderHandler.GetOrders)
                        }</span>
                }

                <span class="cov0" title="0">api.GET("/categories", s.productHandler.GetCategories)
                api.GET("/products", s.productHandler.GetProducts)
                api.GET("/products/:id", s.productHandler.GetProduct)</span>
        }

        <span class="cov0" title="0">return router</span>
}

func (s *Server) healthCheck(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"status": "ok"})
}</span>

func (s *Server) corsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, GET, PUT, DELETE, OPTIONS")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/events"
        "github.com/JihadRinaldi/go-shop/internal/models"
        "github.com/JihadRinaldi/go-shop/internal/repositories"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "gorm.io/gorm"
)

type AuthService struct {
        config         *config.Config
        eventPublisher events.Publisher
        userRepo       repositories.UserRepositoryInterface
        cartRepo       repositories.CartRepositoryInterface
}

func NewAuthService(db *gorm.DB, config *config.Config, eventPublisher events.Publisher) *AuthService <span class="cov0" title="0">{
        return &amp;AuthService{
                config:         config,
                eventPublisher: eventPublisher,
                userRepo:       repositories.NewUserRepository(db),
                cartRepo:       repositories.NewCartRepository(db),
        }
}</span>

func (s *AuthService) Register(req *dto.RegisterRequest) (*dto.AuthResponse, error) <span class="cov8" title="1">{
        if _, err := s.userRepo.GetByEmail(req.Email); err == nil </span><span class="cov8" title="1">{
                return nil, errors.New("email already in use")
        }</span>

        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user := models.User{
                Email:     req.Email,
                Password:  hashedPassword,
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Phone:     req.Phone,
                Role:      models.UserRoleCustomer,
        }

        if err := s.userRepo.Create(&amp;user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cart := models.Cart{UserID: user.ID}
        if err := s.cartRepo.Create(&amp;cart); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Unable to create cart")
        }</span>

        <span class="cov8" title="1">return s.generateAuthResponse(&amp;user)</span>

}

func (s *AuthService) Login(req *dto.LoginRequest) (*dto.AuthResponse, error) <span class="cov8" title="1">{
        user, err := s.userRepo.GetByEmailAndActive(req.Email, true)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid credentials")
        }</span>

        <span class="cov8" title="1">if !utils.CheckPassword(req.Password, user.Password) </span><span class="cov8" title="1">{
                return nil, errors.New("invalid credentials")
        }</span>

        <span class="cov8" title="1">return s.generateAuthResponse(user)</span>
}

func (s *AuthService) RefreshToken(req *dto.RefreshTokenRequest) (*dto.AuthResponse, error) <span class="cov0" title="0">{
        claims, err := utils.ValidateToken(req.RefreshToken, s.config.JWT.SecretKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid refresh token")
        }</span>

        // var refreshToken models.RefreshToken
        <span class="cov0" title="0">refreshToken, err := s.userRepo.GetValidRefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("refresh token not found or expired")
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.GetByID(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        <span class="cov0" title="0">if err := s.userRepo.DeleteRefreshTokenByID(refreshToken.ID); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                _ = err
        }</span>

        <span class="cov0" title="0">return s.generateAuthResponse(user)</span>
}

func (s *AuthService) Logout(refreshToken string) error <span class="cov8" title="1">{
        return s.userRepo.DeleteRefreshToken(refreshToken)
}</span>

func (s *AuthService) generateAuthResponse(user *models.User) (*dto.AuthResponse, error) <span class="cov8" title="1">{
        accessToken, refreshToken, err := utils.GenerateToken(
                &amp;s.config.JWT,
                user.ID,
                user.Email,
                string(user.Role),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">refreshTokenModel := models.RefreshToken{
                UserID:    user.ID,
                Token:     refreshToken,
                ExpiredAt: time.Now().Add(s.config.JWT.RefreshTokenExpires),
        }

        if err := s.userRepo.CreateRefreshToken(&amp;refreshTokenModel); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = s.eventPublisher.Publish("USER_LOGGED_IN", user, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Failed to publish USER_LOGGED_IN event:", err)
        }</span>

        <span class="cov8" title="1">return &amp;dto.AuthResponse{
                User: dto.UserResponse{
                        ID:        user.ID,
                        Email:     user.Email,
                        FirstName: user.FirstName,
                        LastName:  user.LastName,
                        Phone:     user.Phone,
                        Role:      string(user.Role),
                        IsActive:  user.IsActive,
                        CreatedAt: user.CreatedAt,
                        UpdatedAt: user.UpdatedAt,
                },
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        }, nil</span>

}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "errors"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/models"
        "github.com/JihadRinaldi/go-shop/internal/repositories"
        "gorm.io/gorm"
)

type CartService struct {
        db          *gorm.DB
        config      *config.Config
        cartRepo    repositories.CartRepositoryInterface
        productRepo repositories.ProductRepositoryInterface
}

func NewCartService(db *gorm.DB, config *config.Config) *CartService <span class="cov0" title="0">{
        return &amp;CartService{
                db:          db,
                config:      config,
                cartRepo:    repositories.NewCartRepository(db),
                productRepo: repositories.NewProductRepository(db),
        }
}</span>

func (s *CartService) GetCart(userID uint) (*dto.CartResponse, error) <span class="cov0" title="0">{
        var cart models.Cart
        err := s.db.Preload("CartItems.Product.Category").Where("user_id = ?", userID).First(&amp;cart).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.toCartResponse(&amp;cart), nil</span>
}

func (s *CartService) AddToCart(userID uint, req dto.AddToCartRequest) (*dto.CartResponse, error) <span class="cov8" title="1">{
        product, err := s.productRepo.GetByID(req.ProductID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("product not found")
        }</span>

        <span class="cov8" title="1">if product.Stock &lt; req.Quantity </span><span class="cov8" title="1">{
                return nil, errors.New("insufficient product stock")
        }</span>

        <span class="cov0" title="0">cart, err := s.cartRepo.GetByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                cart = &amp;models.Cart{UserID: userID}
                if err := s.cartRepo.Create(cart); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Check if item already exists in cart
        <span class="cov0" title="0">var cartItem models.CartItem
        if err := s.db.Where("cart_id = ? AND product_id = ?", cart.ID, req.ProductID).First(&amp;cartItem).Error; err != nil </span><span class="cov0" title="0">{
                // Create new cart item
                cartItem = models.CartItem{
                        CartID:    cart.ID,
                        ProductID: req.ProductID,
                        Quantity:  req.Quantity,
                }
                s.db.Create(&amp;cartItem)
        }</span> else<span class="cov0" title="0"> {
                // Update existing cart item
                cartItem.Quantity += req.Quantity
                if cartItem.Quantity &gt; product.Stock </span><span class="cov0" title="0">{
                        return nil, errors.New("insufficient stock")
                }</span>
                <span class="cov0" title="0">s.db.Save(&amp;cartItem)</span>
        }

        <span class="cov0" title="0">return s.GetCart(userID)</span>
}

func (s *CartService) UpdateCartItem(userID uint, itemID uint, req dto.UpdateCartItemRequest) (*dto.CartResponse, error) <span class="cov0" title="0">{
        var cartItem models.CartItem
        err := s.db.Joins("JOIN carts ON carts.id = cart_items.cart_id").
                Where("carts.user_id = ? AND cart_items.id = ?", userID, itemID).
                First(&amp;cartItem).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("cart item not found")
        }</span>

        <span class="cov0" title="0">product, err := s.productRepo.GetByID(cartItem.ProductID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("product not found")
        }</span>

        <span class="cov0" title="0">if req.Quantity &gt; product.Stock </span><span class="cov0" title="0">{
                return nil, errors.New("insufficient product stock")
        }</span>

        <span class="cov0" title="0">cartItem.Quantity = req.Quantity
        s.db.Save(&amp;cartItem)

        return s.GetCart(userID)</span>
}

func (s *CartService) RemoveCartItem(userID uint, itemID uint) error <span class="cov0" title="0">{
        return s.db.Joins("JOIN carts ON carts.id = cart_items.cart_id").
                Where("carts.user_id = ? ANd cart_items.id = ?", userID, itemID).
                Delete(&amp;models.CartItem{}).Error
}</span>

func (s *CartService) toCartResponse(cart *models.Cart) *dto.CartResponse <span class="cov0" title="0">{
        cartItems := make([]dto.CartItemResponse, len(cart.CartItems))
        var total float64

        for i, item := range cart.CartItems </span><span class="cov0" title="0">{
                subTotal := float64(cart.CartItems[i].Quantity) * cart.CartItems[i].Product.Price
                total += subTotal

                cartItems[i] = dto.CartItemResponse{
                        ID: item.ID,
                        Product: dto.ProductResponse{
                                ID:          item.Product.ID,
                                Name:        item.Product.Name,
                                Description: item.Product.Description,
                                Price:       item.Product.Price,
                                Category: dto.CategoryResponse{
                                        ID:   item.Product.Category.ID,
                                        Name: item.Product.Category.Name,
                                },
                        },
                        Quantity: item.Quantity,
                        Subtotal: subTotal,
                }
        }</span>

        <span class="cov0" title="0">return &amp;dto.CartResponse{
                ID:        cart.ID,
                UserID:    cart.UserID,
                CartItems: cartItems,
                Total:     total,
                CreatedAt: cart.CreatedAt,
                UpdatedAt: cart.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "errors"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/models"
        "github.com/JihadRinaldi/go-shop/internal/repositories"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "gorm.io/gorm"
)

type OrderService struct {
        db          *gorm.DB
        config      *config.Config
        orderRepo   repositories.OrderRepositoryInterface
        cartRepo    repositories.CartRepositoryInterface
        productRepo repositories.ProductRepositoryInterface
}

func NewOrderService(db *gorm.DB, config *config.Config) *OrderService <span class="cov0" title="0">{
        return &amp;OrderService{
                db:          db,
                config:      config,
                orderRepo:   repositories.NewOrderRepository(db),
                cartRepo:    repositories.NewCartRepository(db),
                productRepo: repositories.NewProductRepository(db),
        }
}</span>

func (s *OrderService) CreateOrder(userID uint) (*dto.OrderResponse, error) <span class="cov0" title="0">{
        var orderResponse *dto.OrderResponse

        err := s.db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                var cart models.Cart
                if err := tx.Preload("CartItems.Product").Where("user_id = ?", userID).First(&amp;cart).Error; err != nil </span><span class="cov0" title="0">{
                        return errors.New("cart not found")
                }</span>

                <span class="cov0" title="0">if len(cart.CartItems) == 0 </span><span class="cov0" title="0">{
                        return errors.New("cart is empty")
                }</span>

                <span class="cov0" title="0">var totalAmount float64
                var orderItems []models.OrderItem

                for _, cartItem := range cart.CartItems </span><span class="cov0" title="0">{
                        if cartItem.Product.Stock &lt; cartItem.Quantity </span><span class="cov0" title="0">{
                                return errors.New("insufficient stock for product: " + cartItem.Product.Name)
                        }</span>

                        <span class="cov0" title="0">itemTotal := float64(cartItem.Quantity) * cartItem.Product.Price
                        totalAmount += itemTotal

                        orderItems = append(orderItems, models.OrderItem{
                                ProductID: cartItem.ProductID,
                                Quantity:  cartItem.Quantity,
                                Price:     cartItem.Product.Price,
                        })

                        cartItem.Product.Stock -= cartItem.Quantity
                        if err := tx.Save(&amp;cartItem.Product).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">order := models.Order{
                                UserID:      userID,
                                Status:      models.OrderStatusPending,
                                TotalAmount: totalAmount,
                                OrderItems:  orderItems,
                        }

                        if err := tx.Create(&amp;order).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if err := tx.Where("cart_id = ?", cart.ID).Delete(&amp;models.CartItem{}).Error; err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">response := s.toOrderResponse(&amp;order)
                        orderResponse = &amp;response</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return orderResponse, nil</span>
}

func (s *OrderService) GetOrder(userID uint, orderID uint) (*dto.OrderResponse, error) <span class="cov8" title="1">{
        order, err := s.orderRepo.GetByID(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("order not found")
        }</span>

        <span class="cov8" title="1">if order.UserID != userID </span><span class="cov8" title="1">{
                return nil, errors.New("order not found")
        }</span>

        <span class="cov8" title="1">resp := s.toOrderResponse(order)

        return &amp;resp, nil</span>
}

func (s *OrderService) GetOrders(userID uint, page, limit int) ([]dto.OrderResponse, *utils.PaginationMeta, error) <span class="cov0" title="0">{
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * limit
        var total int64

        s.db.Model(&amp;models.Order{}).Where("user_id = ?", userID).Count(&amp;total)

        orders, err := s.orderRepo.GetByUserID(userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">response := make([]dto.OrderResponse, len(orders))
        for i := range orders </span><span class="cov0" title="0">{
                response[i] = s.toOrderResponse(&amp;orders[i])
        }</span>

        <span class="cov0" title="0">totalPages := int((total + int64(limit) - 1) / int64(limit))
        meta := &amp;utils.PaginationMeta{
                Page:       page,
                Limit:      limit,
                Total:      total,
                TotalPages: totalPages,
        }

        return response, meta, nil</span>
}

func (s *OrderService) toOrderResponse(order *models.Order) dto.OrderResponse <span class="cov8" title="1">{
        var orderItems []dto.OrderItemResponse

        for _, item := range order.OrderItems </span><span class="cov8" title="1">{
                var images []dto.ProductImageResponse
                for _, img := range item.Product.Images </span><span class="cov0" title="0">{
                        images = append(images, dto.ProductImageResponse{
                                ID:        img.ID,
                                URL:       img.URL,
                                AltText:   img.AltText,
                                CreatedAt: img.CreatedAt,
                                IsPrimary: img.IsPrimary,
                        })
                }</span>
                <span class="cov8" title="1">orderItems = append(orderItems, dto.OrderItemResponse{
                        ID: item.ID,
                        Product: dto.ProductResponse{
                                ID:          item.Product.ID,
                                CategoryID:  item.Product.CategoryID,
                                Name:        item.Product.Name,
                                Description: item.Product.Description,
                                Price:       item.Product.Price,
                                Stock:       item.Product.Stock,
                                SKU:         item.Product.SKU,
                                IsActive:    item.Product.IsActive,
                                Category: dto.CategoryResponse{
                                        ID:          item.Product.Category.ID,
                                        Name:        item.Product.Category.Name,
                                        Description: item.Product.Category.Description,
                                        IsActive:    item.Product.Category.IsActive,
                                        CreatedAt:   item.Product.Category.CreatedAt,
                                        UpdatedAt:   item.Product.Category.UpdatedAt,
                                },
                                Images: images,
                        },
                        Quantity:  item.Quantity,
                        Price:     item.Price,
                        CreatedAt: item.CreatedAt,
                })</span>
        }

        <span class="cov8" title="1">return dto.OrderResponse{
                ID:          order.ID,
                UserID:      order.UserID,
                Status:      string(order.Status),
                TotalAmount: order.TotalAmount,
                OrderItems:  orderItems,
                CreatedAt:   order.CreatedAt,
                UpdatedAt:   order.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/models"
        "github.com/JihadRinaldi/go-shop/internal/repositories"
        "github.com/JihadRinaldi/go-shop/internal/utils"
        "gorm.io/gorm"
)

type ProductService struct {
        db          *gorm.DB
        config      *config.Config
        productRepo repositories.ProductRepositoryInterface
        uploadRepo  repositories.UploadRepositoryInterface
}

func NewProductService(db *gorm.DB, config *config.Config) *ProductService <span class="cov0" title="0">{
        return &amp;ProductService{
                db:          db,
                config:      config,
                productRepo: repositories.NewProductRepository(db),
                uploadRepo:  repositories.NewUploadRepository(db),
        }
}</span>

func (s *ProductService) CreateCategory(req *dto.CreateCategoryRequest) (*dto.CategoryResponse, error) <span class="cov0" title="0">{
        category := models.Category{
                Name:        req.Name,
                Description: req.Description,
        }

        if err := s.db.Create(&amp;category).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dto.CategoryResponse{
                ID:          category.ID,
                Name:        category.Name,
                Description: category.Description,
                IsActive:    category.IsActive,
                CreatedAt:   category.CreatedAt,
                UpdatedAt:   category.UpdatedAt,
        }, nil</span>
}

func (s *ProductService) GetCategories() ([]*dto.CategoryResponse, error) <span class="cov0" title="0">{
        var categories []models.Category
        if err := s.db.Where("is_active = ?", true).Find(&amp;categories).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var response = make([]*dto.CategoryResponse, len(categories))
        for i := range categories </span><span class="cov0" title="0">{
                response[i] = &amp;dto.CategoryResponse{
                        ID:          categories[i].ID,
                        Name:        categories[i].Name,
                        Description: categories[i].Description,
                        IsActive:    categories[i].IsActive,
                        CreatedAt:   categories[i].CreatedAt,
                        UpdatedAt:   categories[i].UpdatedAt,
                }
        }</span>

        <span class="cov0" title="0">return response, nil</span>
}

func (s *ProductService) UpdateCategory(id uint, req *dto.UpdateCategoryRequest) (*dto.CategoryResponse, error) <span class="cov0" title="0">{
        var category models.Category
        if err := s.db.First(&amp;category, id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">category.Name = req.Name
        category.Description = req.Description
        category.IsActive = *req.IsActive
        if err := s.db.Save(&amp;category).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dto.CategoryResponse{
                ID:          category.ID,
                Name:        category.Name,
                Description: category.Description,
                IsActive:    category.IsActive,
                CreatedAt:   category.CreatedAt,
                UpdatedAt:   category.UpdatedAt,
        }, nil</span>
}

func (s *ProductService) DeleteCategory(id uint) error <span class="cov0" title="0">{
        return s.db.Delete(&amp;models.Category{}, id).Error
}</span>

func (s *ProductService) CreateProduct(req *dto.CreateProductRequest) (*dto.ProductResponse, error) <span class="cov8" title="1">{
        product := models.Product{
                CategoryID:  req.CategoryID,
                Name:        req.Name,
                Description: req.Description,
                Price:       req.Price,
                Stock:       req.Stock,
                SKU:         req.SKU,
        }

        if err := s.productRepo.Create(&amp;product); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.GetProduct(product.ID)</span>
}

func (s *ProductService) GetProducts(page, limit int) ([]dto.ProductResponse, *utils.PaginationMeta, error) <span class="cov0" title="0">{
        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>

        <span class="cov0" title="0">if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * limit

        var total int64
        s.db.Model(&amp;models.Product{}).Where("is_active = ?", true).Count(&amp;total)

        products, err := s.productRepo.GetAll(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">response := make([]dto.ProductResponse, len(products))
        for i := range products </span><span class="cov0" title="0">{
                response[i] = s.convertToProductResponse(&amp;products[i])
        }</span>

        <span class="cov0" title="0">totalPages := int((total + int64(limit) - 1) / int64(limit))
        meta := &amp;utils.PaginationMeta{
                Page:       page,
                Limit:      limit,
                Total:      total,
                TotalPages: totalPages,
        }

        return response, meta, nil</span>
}

func (s *ProductService) GetProduct(id uint) (*dto.ProductResponse, error) <span class="cov8" title="1">{
        product, err := s.productRepo.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">response := s.convertToProductResponse(product)
        return &amp;response, nil</span>
}

func (s *ProductService) UpdateProduct(id uint, req *dto.UpdateProductRequest) (*dto.ProductResponse, error) <span class="cov8" title="1">{
        product, err := s.productRepo.GetByID(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">product.CategoryID = req.CategoryID
        product.Name = req.Name
        product.Description = req.Description
        product.Price = req.Price
        product.Stock = req.Stock
        product.IsActive = *req.IsActive

        if err := s.productRepo.Update(product); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.GetProduct(product.ID)</span>
}

func (s *ProductService) DeleteProduct(id uint) error <span class="cov8" title="1">{
        return s.productRepo.Delete(id)
}</span>

func (s *ProductService) AddProductImage(productID uint, url, altText string) error <span class="cov8" title="1">{
        images, _ := s.uploadRepo.GetProductImages(productID)
        isPrimary := len(images) == 0

        image := models.ProductImage{
                ProductID: productID,
                URL:       url,
                AltText:   altText,
                IsPrimary: isPrimary,
        }

        return s.uploadRepo.CreateProductImage(&amp;image)
}</span>

func (s *ProductService) convertToProductResponse(product *models.Product) dto.ProductResponse <span class="cov8" title="1">{
        images := make([]dto.ProductImageResponse, len(product.Images))
        for i := range product.Images </span><span class="cov0" title="0">{
                images[i] = dto.ProductImageResponse{
                        ID:        product.Images[i].ID,
                        URL:       product.Images[i].URL,
                        AltText:   product.Images[i].AltText,
                        IsPrimary: product.Images[i].IsPrimary,
                        CreatedAt: product.Images[i].CreatedAt,
                }
        }</span>

        <span class="cov8" title="1">return dto.ProductResponse{
                ID:          product.ID,
                CategoryID:  product.CategoryID,
                Name:        product.Name,
                Description: product.Description,
                Price:       product.Price,
                Stock:       product.Stock,
                SKU:         product.SKU,
                IsActive:    product.IsActive,
                Category: dto.CategoryResponse{
                        ID:          product.Category.ID,
                        Name:        product.Category.Name,
                        Description: product.Category.Description,
                        IsActive:    product.Category.IsActive,
                        CreatedAt:   product.Category.CreatedAt,
                        UpdatedAt:   product.Category.UpdatedAt,
                },
                Images:    images,
                CreatedAt: product.CreatedAt,
                UpdatedAt: product.UpdatedAt,
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package services

import (
        "fmt"
        "mime/multipart"
        "path/filepath"
        "strings"

        "github.com/JihadRinaldi/go-shop/internal/interfaces"
        "github.com/JihadRinaldi/go-shop/internal/models"
        "github.com/JihadRinaldi/go-shop/internal/repositories"
        "github.com/google/uuid"
        "gorm.io/gorm"
)

type UploadService struct {
        provider   interfaces.UploadProvider
        uploadRepo repositories.UploadRepositoryInterface
}

func NewUploadService(db *gorm.DB, provider interfaces.UploadProvider) *UploadService <span class="cov0" title="0">{
        return &amp;UploadService{
                provider:   provider,
                uploadRepo: repositories.NewUploadRepository(db),
        }
}</span>

func (s *UploadService) UploadProductImage(productID uint, file *multipart.FileHeader) (string, error) <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(file.Filename))

        if !isValidImageExtension(ext) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid image extension: %s", ext)
        }</span>

        <span class="cov8" title="1">newFileName := uuid.New().String()

        path := fmt.Sprintf("products/%d/%s%s", productID, newFileName, ext)

        url, err := s.provider.UploadFile(file, path)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">images, _ := s.uploadRepo.GetProductImages(productID)
        isPrimary := len(images) == 0

        image := models.ProductImage{
                ProductID: productID,
                URL:       url,
                AltText:   file.Filename,
                IsPrimary: isPrimary,
        }

        if err := s.uploadRepo.CreateProductImage(&amp;image); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return url, nil</span>
}

func isValidImageExtension(ext string) bool <span class="cov8" title="1">{
        validExtensions := []string{".jpg", ".jpeg", ".png", ".gif", ".webp"}
        for _, v := range validExtensions </span><span class="cov8" title="1">{
                if ext == v </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package services

import (
        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/JihadRinaldi/go-shop/internal/dto"
        "github.com/JihadRinaldi/go-shop/internal/repositories"
        "gorm.io/gorm"
)

type UserService struct {
        config   *config.Config
        userRepo repositories.UserRepositoryInterface
}

func NewUserService(db *gorm.DB, config *config.Config) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                config:   config,
                userRepo: repositories.NewUserRepository(db),
        }
}</span>

func (s *UserService) GetProfile(userID uint) (*dto.UserResponse, error) <span class="cov8" title="1">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;dto.UserResponse{
                ID:        user.ID,
                Email:     user.Email,
                FirstName: user.FirstName,
                LastName:  user.LastName,
                Phone:     user.Phone,
                Role:      string(user.Role),
                IsActive:  user.IsActive,
                CreatedAt: user.CreatedAt,
                UpdatedAt: user.UpdatedAt,
        }, nil</span>
}

func (s *UserService) UpdateProfile(userID uint, req *dto.UpdateProfileRequest) (*dto.UserResponse, error) <span class="cov8" title="1">{
        user, err := s.userRepo.GetByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">user.FirstName = req.FirstName
        user.LastName = req.LastName
        user.Phone = req.Phone

        if err := s.userRepo.Update(user); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return s.GetProfile(userID)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package utils

import (
        "errors"
        "time"

        "github.com/JihadRinaldi/go-shop/internal/config"
        "github.com/golang-jwt/jwt/v5"
)

type Claims struct {
        UserID uint   `json:"user_id"`
        Email  string `json:"email"`
        Role   string `json:"role"`
        jwt.RegisteredClaims
}

func GenerateToken(cfg *config.JWTConfig, userID uint, email, role string) (accessToken, refreshToken string, err error) <span class="cov0" title="0">{
        accessClaims := &amp;Claims{
                UserID: userID,
                Email:  email,
                Role:   role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(cfg.ExpireIn)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        at := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
        accessToken, err = at.SignedString([]byte(cfg.SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">refreshClaims := &amp;Claims{
                UserID: userID,
                Email:  email,
                Role:   role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(cfg.RefreshTokenExpires)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        rt := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
        refreshToken, err = rt.SignedString([]byte(cfg.SecretKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">return accessToken, refreshToken, nil</span>
}

func ValidateToken(tokenString, secret string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(secret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>

}
</pre>
		
		<pre class="file" id="file36" style="display: none">package utils

import "golang.org/x/crypto/bcrypt"

// HashPassword hash password using bcrypt at default cost
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

// CheckPassword checks if password hash is correct
func CheckPassword(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package utils

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type Response struct {
        Success bool        `json:"success"`
        Message string      `json:"message"`
        Data    interface{} `json:"data"`
        Error   string      `json:"error"`
}

type PaginatedResponse struct {
        Response
        Meta PaginationMeta `json:"meta"`
}

type PaginationMeta struct {
        Page       int   `json:"page"`
        Limit      int   `json:"limit"`
        Total      int64 `json:"total"`
        TotalPages int   `json:"total_pages"`
}

func SuccessResponse(c *gin.Context, message string, data interface{}) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, Response{
                Success: true,
                Message: message,
                Data:    data,
        })
}</span>

func CreatedResponse(c *gin.Context, message string, data interface{}) <span class="cov0" title="0">{
        c.JSON(http.StatusCreated, Response{
                Success: true,
                Message: message,
                Data:    data,
        })
}</span>

func ErrorResponse(c *gin.Context, statusCode int, message string, err error) <span class="cov0" title="0">{
        response := Response{
                Success: false,
                Message: message,
        }

        if err != nil </span><span class="cov0" title="0">{
                response.Error = err.Error()
        }</span>

        <span class="cov0" title="0">c.JSON(statusCode, response)</span>
}

func BadRequestResponse(c *gin.Context, message string, err error) <span class="cov0" title="0">{
        ErrorResponse(c, http.StatusBadRequest, message, err)
}</span>

func UnauthorizedResponse(c *gin.Context, message string) <span class="cov0" title="0">{
        ErrorResponse(c, http.StatusUnauthorized, message, nil)
}</span>

func ForbiddenResponse(c *gin.Context, message string) <span class="cov0" title="0">{
        ErrorResponse(c, http.StatusForbidden, message, nil)
}</span>

func NotFoundResponse(c *gin.Context, message string) <span class="cov0" title="0">{
        ErrorResponse(c, http.StatusNotFound, message, nil)
}</span>

func InternalServerErrorResponse(c *gin.Context, message string, err error) <span class="cov0" title="0">{
        ErrorResponse(c, http.StatusInternalServerError, message, err)
}</span>

func PaginatedSuccessResponse(c *gin.Context, message string, data interface{}, meta PaginationMeta) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, PaginatedResponse{
                Response: Response{
                        Success: true,
                        Message: message,
                        Data:    data,
                },
                Meta: meta,
        })
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
